[
  {
    "signature": "subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)",
    "name": "subMap",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ConcurrentNavigableMap",
      "name": "ConcurrentNavigableMap",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ConcurrentNavigableMap",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.concurrent.ConcurrentNavigableMap<K, V>",
      "name": "java.util.concurrent.ConcurrentNavigableMap<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "fromKey"
      },
      {
        "type": {
          "qualifiedName": "boolean",
          "name": "boolean",
          "isArray": false
        },
        "name": "fromInclusive"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "toKey"
      },
      {
        "type": {
          "qualifiedName": "boolean",
          "name": "boolean",
          "isArray": false
        },
        "name": "toInclusive"
      }
    ],
    "protocol": {
      "member": "subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "headMap(K toKey, boolean inclusive)",
    "name": "headMap",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ConcurrentNavigableMap",
      "name": "ConcurrentNavigableMap",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ConcurrentNavigableMap",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.concurrent.ConcurrentNavigableMap<K, V>",
      "name": "java.util.concurrent.ConcurrentNavigableMap<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "toKey"
      },
      {
        "type": {
          "qualifiedName": "boolean",
          "name": "boolean",
          "isArray": false
        },
        "name": "inclusive"
      }
    ],
    "protocol": {
      "member": "headMap(K toKey, boolean inclusive)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "tailMap(K fromKey, boolean inclusive)",
    "name": "tailMap",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ConcurrentNavigableMap",
      "name": "ConcurrentNavigableMap",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ConcurrentNavigableMap",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.concurrent.ConcurrentNavigableMap<K, V>",
      "name": "java.util.concurrent.ConcurrentNavigableMap<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "fromKey"
      },
      {
        "type": {
          "qualifiedName": "boolean",
          "name": "boolean",
          "isArray": false
        },
        "name": "inclusive"
      }
    ],
    "protocol": {
      "member": "tailMap(K fromKey, boolean inclusive)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "subMap(K fromKey, K toKey)",
    "name": "subMap",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ConcurrentNavigableMap",
      "name": "ConcurrentNavigableMap",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ConcurrentNavigableMap",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.concurrent.ConcurrentNavigableMap<K, V>",
      "name": "java.util.concurrent.ConcurrentNavigableMap<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "fromKey"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "toKey"
      }
    ],
    "protocol": {
      "member": "subMap(K fromKey, K toKey)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "headMap(K toKey)",
    "name": "headMap",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ConcurrentNavigableMap",
      "name": "ConcurrentNavigableMap",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ConcurrentNavigableMap",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.concurrent.ConcurrentNavigableMap<K, V>",
      "name": "java.util.concurrent.ConcurrentNavigableMap<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "toKey"
      }
    ],
    "protocol": {
      "member": "headMap(K toKey)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "tailMap(K fromKey)",
    "name": "tailMap",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ConcurrentNavigableMap",
      "name": "ConcurrentNavigableMap",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ConcurrentNavigableMap",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.concurrent.ConcurrentNavigableMap<K, V>",
      "name": "java.util.concurrent.ConcurrentNavigableMap<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "fromKey"
      }
    ],
    "protocol": {
      "member": "tailMap(K fromKey)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "descendingMap()",
    "name": "descendingMap",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ConcurrentNavigableMap",
      "name": "ConcurrentNavigableMap",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ConcurrentNavigableMap",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.concurrent.ConcurrentNavigableMap<K, V>",
      "name": "java.util.concurrent.ConcurrentNavigableMap<K, V>",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "descendingMap()",
      "comment": "Returns a reverse order view of the mappings contained in this map. The descending map is backed by this map, so changes to the map are reflected in the descending map, and vice-versa. The returned map has an ordering equivalent to method_0 method_5(method_1. The expression method_2method_3 returns a view of m essentially equivalent to m.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "navigableKeySet()",
    "name": "navigableKeySet",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ConcurrentNavigableMap",
      "name": "ConcurrentNavigableMap",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ConcurrentNavigableMap",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.NavigableSet<K>",
      "name": "java.util.NavigableSet<K>",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "navigableKeySet()",
      "comment": "Returns a NavigableSet view of the keys contained in this map. The set's iterator returns the keys in ascending order. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. The set supports element removal, which removes the corresponding mapping from the map, via the method_0, method_1, removeAll, retainAll, and clear operations. It does not support the add or addAll operations. The view's iterators and spliterators are <i>weakly consistent</i>.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "keySet()",
    "name": "keySet",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ConcurrentNavigableMap",
      "name": "ConcurrentNavigableMap",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ConcurrentNavigableMap",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.NavigableSet<K>",
      "name": "java.util.NavigableSet<K>",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "keySet()",
      "comment": "Returns a NavigableSet view of the keys contained in this map. The set's iterator returns the keys in ascending order. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. The set supports element removal, which removes the corresponding mapping from the map, via the method_0, method_1, removeAll, retainAll, and clear operations. It does not support the add or addAll operations. The view's iterators and spliterators are <i>weakly consistent</i>. This method is equivalent to method navigableKeySet.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "descendingKeySet()",
    "name": "descendingKeySet",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ConcurrentNavigableMap",
      "name": "ConcurrentNavigableMap",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ConcurrentNavigableMap",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.NavigableSet<K>",
      "name": "java.util.NavigableSet<K>",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "descendingKeySet()",
      "comment": "Returns a reverse order NavigableSet view of the keys contained in this map. The set's iterator returns the keys in descending order. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. The set supports element removal, which removes the corresponding mapping from the map, via the method_0, method_1, removeAll, retainAll, and clear operations. It does not support the add or addAll operations. The view's iterators and spliterators are <i>weakly consistent</i>.",
      "kind": "FreeText",
      "condition": ""
    }
  }
]