[
  {
    "signature": "java.util.concurrent.Phaser()",
    "name": "java.util.concurrent.Phaser",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.Phaser",
      "name": "Phaser",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.Phaser",
    "isVarArgs": false,
    "parameters": [],
    "protocol": {
      "member": "java.util.concurrent.Phaser()",
      "comment": "Creates a new phaser with no initially registered parties, no parent, and initial phase number 0. Any thread using this phaser will need to first register for it.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "java.util.concurrent.Phaser(int parties)",
    "name": "java.util.concurrent.Phaser",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.Phaser",
      "name": "Phaser",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.Phaser",
    "isVarArgs": false,
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "parties"
      }
    ],
    "protocol": {
      "member": "java.util.concurrent.Phaser(int parties)",
      "comment": "Creates a new phaser with the given number of registered unarrived parties, no parent, and initial phase number 0.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "java.util.concurrent.Phaser(java.util.concurrent.Phaser parent)",
    "name": "java.util.concurrent.Phaser",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.Phaser",
      "name": "Phaser",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.Phaser",
    "isVarArgs": false,
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.concurrent.Phaser",
          "name": "Phaser",
          "isArray": false
        },
        "name": "parent"
      }
    ],
    "protocol": {
      "member": "java.util.concurrent.Phaser(java.util.concurrent.Phaser parent)",
      "comment": "Equivalent to method_1.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "java.util.concurrent.Phaser(java.util.concurrent.Phaser parent, int parties)",
    "name": "java.util.concurrent.Phaser",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.Phaser",
      "name": "Phaser",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.Phaser",
    "isVarArgs": false,
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.concurrent.Phaser",
          "name": "Phaser",
          "isArray": false
        },
        "name": "parent"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "parties"
      }
    ],
    "protocol": {
      "member": "java.util.concurrent.Phaser(java.util.concurrent.Phaser parent, int parties)",
      "comment": "Creates a new phaser with the given parent and number of registered unarrived parties. When the given parent is non-null and the given number of parties is greater than zero, this child phaser is registered with its parent.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "register()",
    "name": "register",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.Phaser",
      "name": "Phaser",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.Phaser",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "register()",
      "comment": "Adds a new unarrived party to this phaser. If an ongoing invocation of method_0 is in progress, this method may await its completion before returning. If this phaser has a parent, and this phaser previously had no registered parties, this child phaser is also registered with its parent. If this phaser is terminated, the attempt to register has no effect, and a negative value is returned.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "bulkRegister(int parties)",
    "name": "bulkRegister",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.Phaser",
      "name": "Phaser",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.Phaser",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "parties"
      }
    ],
    "protocol": {
      "member": "bulkRegister(int parties)",
      "comment": "Adds the given number of new unarrived parties to this phaser. If an ongoing invocation of method_0 is in progress, this method may await its completion before returning. If this phaser has a parent, and the given number of parties is greater than zero, and this phaser previously had no registered parties, this child phaser is also registered with its parent. If this phaser is terminated, the attempt to register has no effect, and a negative value is returned.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "arrive()",
    "name": "arrive",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.Phaser",
      "name": "Phaser",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.Phaser",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "arrive()",
      "comment": "Arrives at this phaser, without waiting for others to arrive. It is a usage error for an unregistered party to invoke this method. However, this error may result in an IllegalStateException only upon some subsequent operation on this phaser, if ever.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "arriveAndDeregister()",
    "name": "arriveAndDeregister",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.Phaser",
      "name": "Phaser",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.Phaser",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "arriveAndDeregister()",
      "comment": "Arrives at this phaser and deregisters from it without waiting for others to arrive. Deregistration reduces the number of parties required to advance in future phases. If this phaser has a parent, and deregistration causes this phaser to have zero parties, this phaser is also deregistered from its parent. It is a usage error for an unregistered party to invoke this method. However, this error may result in an IllegalStateException only upon some subsequent operation on this phaser, if ever.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "arriveAndAwaitAdvance()",
    "name": "arriveAndAwaitAdvance",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.Phaser",
      "name": "Phaser",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.Phaser",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "arriveAndAwaitAdvance()",
      "comment": "Arrives at this phaser and awaits others. Equivalent in effect to method_0. If you need to await with interruption or timeout, you can arrange this with an analogous construction using one of the other forms of the awaitAdvance method. If instead you need to deregister upon arrival, use method_1. It is a usage error for an unregistered party to invoke this method. However, this error may result in an IllegalStateException only upon some subsequent operation on this phaser, if ever.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "awaitAdvance(int phase)",
    "name": "awaitAdvance",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.Phaser",
      "name": "Phaser",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.Phaser",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "phase"
      }
    ],
    "protocol": {
      "member": "awaitAdvance(int phase)",
      "comment": "Awaits the phase of this phaser to advance from the given phase value, returning immediately if the current phase is not equal to the given phase value or this phaser is terminated.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "awaitAdvanceInterruptibly(int phase)",
    "name": "awaitAdvanceInterruptibly",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.Phaser",
      "name": "Phaser",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.Phaser",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "phase"
      }
    ],
    "protocol": {
      "member": "awaitAdvanceInterruptibly(int phase)",
      "comment": "Awaits the phase of this phaser to advance from the given phase value, throwing InterruptedException if interrupted while waiting, or returning immediately if the current phase is not equal to the given phase value or this phaser is terminated.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "awaitAdvanceInterruptibly(int phase, long timeout, java.util.concurrent.TimeUnit unit)",
    "name": "awaitAdvanceInterruptibly",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.Phaser",
      "name": "Phaser",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.Phaser",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "phase"
      },
      {
        "type": {
          "qualifiedName": "long",
          "name": "long",
          "isArray": false
        },
        "name": "timeout"
      },
      {
        "type": {
          "qualifiedName": "java.util.concurrent.TimeUnit",
          "name": "TimeUnit",
          "isArray": false
        },
        "name": "unit"
      }
    ],
    "protocol": {
      "member": "awaitAdvanceInterruptibly(int phase, long timeout, java.util.concurrent.TimeUnit unit)",
      "comment": "Awaits the phase of this phaser to advance from the given phase value or the given timeout to elapse, throwing InterruptedException if interrupted while waiting, or returning immediately if the current phase is not equal to the given phase value or this phaser is terminated.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "forceTermination()",
    "name": "forceTermination",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.Phaser",
      "name": "Phaser",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.Phaser",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "forceTermination()",
      "comment": "Forces this phaser to enter termination state. Counts of registered parties are unaffected. If this phaser is a member of a tiered set of phasers, then all of the phasers in the set are terminated. If this phaser is already terminated, this method has no effect. This method may be useful for coordinating recovery after one or more tasks encounter unexpected exceptions.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getPhase()",
    "name": "getPhase",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.Phaser",
      "name": "Phaser",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.Phaser",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getPhase()",
      "comment": "Returns the current phase number. The maximum phase number is method_1, after which it restarts at zero. Upon termination, the phase number is negative, in which case the prevailing phase prior to termination may be obtained via method_0 + method_2.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getRegisteredParties()",
    "name": "getRegisteredParties",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.Phaser",
      "name": "Phaser",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.Phaser",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getRegisteredParties()",
      "comment": "Returns the number of parties registered at this phaser.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getArrivedParties()",
    "name": "getArrivedParties",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.Phaser",
      "name": "Phaser",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.Phaser",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getArrivedParties()",
      "comment": "Returns the number of registered parties that have arrived at the current phase of this phaser. If this phaser has terminated, the returned value is meaningless and arbitrary.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getUnarrivedParties()",
    "name": "getUnarrivedParties",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.Phaser",
      "name": "Phaser",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.Phaser",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getUnarrivedParties()",
      "comment": "Returns the number of registered parties that have not yet arrived at the current phase of this phaser. If this phaser has terminated, the returned value is meaningless and arbitrary.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getParent()",
    "name": "getParent",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.Phaser",
      "name": "Phaser",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.Phaser",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.concurrent.Phaser",
      "name": "java.util.concurrent.Phaser",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getParent()",
      "comment": "Returns the parent of this phaser, or null if none.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getRoot()",
    "name": "getRoot",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.Phaser",
      "name": "Phaser",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.Phaser",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.concurrent.Phaser",
      "name": "java.util.concurrent.Phaser",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getRoot()",
      "comment": "Returns the root ancestor of this phaser, which is the same as this phaser if it has no parent.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "isTerminated()",
    "name": "isTerminated",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.Phaser",
      "name": "Phaser",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.Phaser",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "isTerminated()",
      "comment": "Returns true if this phaser has been terminated.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "onAdvance(int phase, int registeredParties)",
    "name": "onAdvance",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.Phaser",
      "name": "Phaser",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.Phaser",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "phase"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "registeredParties"
      }
    ],
    "protocol": {
      "member": "onAdvance(int phase, int registeredParties)",
      "comment": "Overridable method to perform an action upon impending phase advance, and to control termination. This method is invoked upon arrival of the party advancing this phaser (when all other waiting parties are dormant). If this method returns true, this phaser will be set to a final termination state upon advance, and subsequent calls to method_2 will return true. Any (unchecked) Exception or Error thrown by an invocation of this method is propagated to the party attempting to advance this phaser, in which case no advance occurs. The arguments to this method provide the state of the phaser prevailing for the current transition. The effects of invoking arrival, registration, and waiting methods on this phaser from within onAdvance are unspecified and should not be relied on. If this phaser is a member of a tiered set of phasers, then onAdvance is invoked only for its root phaser on each advance. To support the most common use cases, the default implementation of this method returns true when the number of registered parties has become zero as the result of a party invoking arriveAndDeregister. You can disable this behavior, thus enabling continuation upon future registrations, by overriding this method to always return false}:  {@code Phaser phaser = method_0 { protected boolean method_1 { return false;  }}",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "toString()",
    "name": "toString",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.Phaser",
      "name": "Phaser",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.Phaser",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.lang.String",
      "name": "java.lang.String",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "toString()",
      "comment": "Returns a string identifying this phaser, as well as its state. The state, in brackets, includes the String \"phase = \" followed by the phase number, \"parties = \" followed by the number of registered parties, and \"arrived = \" followed by the number of arrived parties.",
      "kind": "FreeText",
      "condition": ""
    }
  }
]