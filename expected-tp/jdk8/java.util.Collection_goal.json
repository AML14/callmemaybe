[
  {
    "signature": "size()",
    "name": "size",
    "containingClass": {
      "qualifiedName": "java.util.Collection",
      "name": "Collection",
      "isArray": false
    },
    "targetClass": "java.util.Collection",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "size()",
      "comment": "Returns the number of elements in this collection. If this collection contains more than method_0 elements, returns method_0.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "isEmpty()",
    "name": "isEmpty",
    "containingClass": {
      "qualifiedName": "java.util.Collection",
      "name": "Collection",
      "isArray": false
    },
    "targetClass": "java.util.Collection",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "isEmpty()",
      "comment": "Returns true if this collection contains no elements.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "contains(java.lang.Object o)",
    "name": "contains",
    "containingClass": {
      "qualifiedName": "java.util.Collection",
      "name": "Collection",
      "isArray": false
    },
    "targetClass": "java.util.Collection",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "o"
      }
    ],
    "protocol": {
      "member": "contains(java.lang.Object o)",
      "comment": "Returns true if this collection contains the specified element. More formally, returns true if and only if this collection contains at least one element e such that (o==null&nbsp;?&nbsp;e==null&nbsp;:&nbsp;method_0.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "iterator()",
    "name": "iterator",
    "containingClass": {
      "qualifiedName": "java.util.Collection",
      "name": "Collection",
      "isArray": false
    },
    "targetClass": "java.util.Collection",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.Iterator<E>",
      "name": "java.util.Iterator<E>",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "iterator()",
      "comment": "Returns an iterator over the elements in this collection. There are no guarantees concerning the order in which the elements are returned (unless this collection is an instance of some class that provides a guarantee).",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "toArray()",
    "name": "toArray",
    "containingClass": {
      "qualifiedName": "java.util.Collection",
      "name": "Collection",
      "isArray": false
    },
    "targetClass": "java.util.Collection",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.lang.Object[]",
      "name": "java.lang.Object[]",
      "isArray": true
    },
    "parameters": [],
    "protocol": {
      "member": "toArray()",
      "comment": "Returns an array containing all of the elements in this collection. If this collection makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order. The returned array will be \"safe\" in that no references to it are maintained by this collection. (In other words, this method must allocate a new array even if this collection is backed by an array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "toArray(T[] a)",
    "name": "toArray",
    "containingClass": {
      "qualifiedName": "java.util.Collection",
      "name": "Collection",
      "isArray": false
    },
    "targetClass": "java.util.Collection",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "T[]",
      "name": "T[]",
      "isArray": true
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "toArray(T[] a)",
      "comment": "Returns an array containing all of the elements in this collection; the runtime type of the returned array is that of the specified array. If the collection fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this collection. If this collection fits in the specified array with room to spare (imethod_4., the array has more elements than this collection), the element in the array immediately following the end of the collection is set to null. (This is useful in determining the length of this collection only if the caller knows that this collection does not contain any null elements.) If this collection makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order. Like the method_0 method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a collection known to contain only strings. The following code can be used to dump the collection into a newly allocated array of String:  String[] y = method_1; Note that method_2 is identical in function to method_0.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "add(E e)",
    "name": "add",
    "containingClass": {
      "qualifiedName": "java.util.Collection",
      "name": "Collection",
      "isArray": false
    },
    "targetClass": "java.util.Collection",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "e"
      }
    ],
    "protocol": {
      "member": "add(E e)",
      "comment": "Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.",
      "kind": "FreeText",
      "condition": "receiverObjectID.contains(args[0])<-receiverObjectID.add(args[0])"
    }
  },
  {
    "signature": "remove(java.lang.Object o)",
    "name": "remove",
    "containingClass": {
      "qualifiedName": "java.util.Collection",
      "name": "Collection",
      "isArray": false
    },
    "targetClass": "java.util.Collection",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "o"
      }
    ],
    "protocol": {
      "member": "remove(java.lang.Object o)",
      "comment": "Removes a single instance of the specified element from this collection, if it is present (optional operation). More formally, removes an element e such that (o==null&nbsp;?&nbsp;e==null&nbsp;:&nbsp;method_0, if this collection contains one or more such elements. Returns true if this collection contained the specified element (or equivalently, if this collection changed as a result of the call).",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "containsAll(java.util.Collection<?> c)",
    "name": "containsAll",
    "containingClass": {
      "qualifiedName": "java.util.Collection",
      "name": "Collection",
      "isArray": false
    },
    "targetClass": "java.util.Collection",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Collection",
          "name": "Collection",
          "isArray": false
        },
        "name": "c"
      }
    ],
    "protocol": {
      "member": "containsAll(java.util.Collection<?> c)",
      "comment": "Returns true if this collection contains all of the elements in the specified collection.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "addAll(java.util.Collection<? extends E> c)",
    "name": "addAll",
    "containingClass": {
      "qualifiedName": "java.util.Collection",
      "name": "Collection",
      "isArray": false
    },
    "targetClass": "java.util.Collection",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Collection",
          "name": "Collection",
          "isArray": false
        },
        "name": "c"
      }
    ],
    "protocol": {
      "member": "addAll(java.util.Collection<? extends E> c)",
      "comment": "Adds all of the elements in the specified collection to this collection (optional operation). The behavior of this operation is undefined if the specified collection is modified while the operation is in progress. (This implies that the behavior of this call is undefined if the specified collection is this collection, and this collection is nonempty.)",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "removeAll(java.util.Collection<?> c)",
    "name": "removeAll",
    "containingClass": {
      "qualifiedName": "java.util.Collection",
      "name": "Collection",
      "isArray": false
    },
    "targetClass": "java.util.Collection",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Collection",
          "name": "Collection",
          "isArray": false
        },
        "name": "c"
      }
    ],
    "protocol": {
      "member": "removeAll(java.util.Collection<?> c)",
      "comment": "Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.",
      "kind": "FreeText",
      "condition": "Collections.disjoint(receiverObjectID, args[0])<-receiverObjectID.removeAll(args[0])"
    }
  },
  {
    "signature": "removeIf(java.util.function.Predicate<? super E> filter)",
    "name": "removeIf",
    "containingClass": {
      "qualifiedName": "java.util.Collection",
      "name": "Collection",
      "isArray": false
    },
    "targetClass": "java.util.Collection",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.function.Predicate",
          "name": "Predicate",
          "isArray": false
        },
        "name": "filter"
      }
    ],
    "protocol": {
      "member": "removeIf(java.util.function.Predicate<? super E> filter)",
      "comment": "Removes all of the elements of this collection that satisfy the given predicate. Errors or runtime exceptions thrown during iteration or by the predicate are relayed to the caller. @implSpec The default implementation traverses all elements of the collection using its method_1. Each matching element is removed using method_0. If the collection's iterator does not support removal then an UnsupportedOperationException will be thrown on the first matching element.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "retainAll(java.util.Collection<?> c)",
    "name": "retainAll",
    "containingClass": {
      "qualifiedName": "java.util.Collection",
      "name": "Collection",
      "isArray": false
    },
    "targetClass": "java.util.Collection",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Collection",
          "name": "Collection",
          "isArray": false
        },
        "name": "c"
      }
    ],
    "protocol": {
      "member": "retainAll(java.util.Collection<?> c)",
      "comment": "Retains only the elements in this collection that are contained in the specified collection (optional operation). In other words, removes from this collection all of its elements that are not contained in the specified collection.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "clear()",
    "name": "clear",
    "containingClass": {
      "qualifiedName": "java.util.Collection",
      "name": "Collection",
      "isArray": false
    },
    "targetClass": "java.util.Collection",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "clear()",
      "comment": "Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.",
      "kind": "FreeText",
      "condition": "receiverObjectID.isEmpty()<-receiverObjectID.clear()"
    }
  },
  {
    "signature": "equals(java.lang.Object o)",
    "name": "equals",
    "containingClass": {
      "qualifiedName": "java.util.Collection",
      "name": "Collection",
      "isArray": false
    },
    "targetClass": "java.util.Collection",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "o"
      }
    ],
    "protocol": {
      "member": "equals(java.lang.Object o)",
      "comment": "Compares the specified object with this collection for equality.  While the Collection interface adds no stipulations to the general contract for the method_2, programmers who implement the Collection interface \"directly\" (in other words, create a class that is a Collection but is not a Set or a List) must exercise care if they choose to override the method_2. It is not necessary to do so, and the simplest course of action is to rely on Object's implementation, but the implementor may wish to implement a \"value comparison\" in place of the default \"reference comparison.\" (The List and Set interfaces mandate such value comparisons.) The general contract for the method_2 method states that equals must be symmetric (in other words, method_0 if and only if method_1). The contracts for Listmethod_5 and Setmethod_5 state that lists are only equal to other lists, and sets to other sets. Thus, a custom equals method for a collection class that implements neither the List nor Set interface must return false when this collection is compared to any list or set. (By the same logic, it is not possible to write a class that correctly implements both the Set and List interfaces.)",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "hashCode()",
    "name": "hashCode",
    "containingClass": {
      "qualifiedName": "java.util.Collection",
      "name": "Collection",
      "isArray": false
    },
    "targetClass": "java.util.Collection",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "hashCode()",
      "comment": "Returns the hash code value for this collection. While the Collection interface adds no stipulations to the general contract for the method_3 method, programmers should take note that any class that overrides the method_4 method must also override the method_3 method in order to satisfy the general contract for the method_3 method. In particular, method_0 implies that method_1==method_2.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "spliterator()",
    "name": "spliterator",
    "containingClass": {
      "qualifiedName": "java.util.Collection",
      "name": "Collection",
      "isArray": false
    },
    "targetClass": "java.util.Collection",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.Spliterator<E>",
      "name": "java.util.Spliterator<E>",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "spliterator()",
      "comment": "Creates a Spliterator over the elements in this collection. Implementations should document characteristic values reported by the spliterator. Such characteristic values are not required to be reported if the spliterator reports method_9 and this collection contains no elements. The default implementation should be overridden by subclasses that can return a more efficient spliterator. In order to preserve expected laziness behavior for the method_0 and method_1} methods, spliterators should either have the characteristic of IMMUTABLE or CONCURRENT, or be <a href=\"method_12method_13\">late-binding</a>. If none of these is practical, the overriding class should describe the spliterator's documented policy of binding and structural interference, and should override the method_0 and method_1 methods to create streams using a Supplier of the spliterator, as in: Stream<E> s = method_4 -> method_5, spliteratorCharacteristics)  These requirements ensure that streams produced by the method_0 and method_1 methods will reflect the contents of the collection as of initiation of the terminal stream operation. @implSpec The default implementation creates a <a href=\"method_12method_13\">late-binding</a> spliterator from the collections's Iterator. The spliterator inherits the fail-fast properties of the collection's iterator.  The created Spliterator reports method_9. @implNote The created Spliterator additionally reports method_22. If a spliterator covers no elements then the reporting of additional characteristic values, beyond that of SIZED and SUBSIZED, does not aid clients to control, specialize or simplify computation. However, this does enable shared use of an immutable and empty spliterator instance (see method_8) for empty collections, and enables clients to determine if such a spliterator covers no elements.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "stream()",
    "name": "stream",
    "containingClass": {
      "qualifiedName": "java.util.Collection",
      "name": "Collection",
      "isArray": false
    },
    "targetClass": "java.util.Collection",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.stream.Stream<E>",
      "name": "java.util.stream.Stream<E>",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "stream()",
      "comment": "Returns a sequential Stream with this collection as its source. This method should be overridden when the method_0 method cannot return a spliterator that is IMMUTABLE, CONCURRENT, or late-binding. (See method_0 for details.) @implSpec The default implementation creates a sequential Stream from the collection's Spliterator.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "parallelStream()",
    "name": "parallelStream",
    "containingClass": {
      "qualifiedName": "java.util.Collection",
      "name": "Collection",
      "isArray": false
    },
    "targetClass": "java.util.Collection",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.stream.Stream<E>",
      "name": "java.util.stream.Stream<E>",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "parallelStream()",
      "comment": "Returns a possibly parallel Stream with this collection as its source. It is allowable for this method to return a sequential stream. This method should be overridden when the method_0 method cannot return a spliterator that is IMMUTABLE, CONCURRENT, or late-binding. (See method_0 for details.) @implSpec The default implementation creates a parallel Stream from the collection's Spliterator.",
      "kind": "FreeText",
      "condition": ""
    }
  }
]