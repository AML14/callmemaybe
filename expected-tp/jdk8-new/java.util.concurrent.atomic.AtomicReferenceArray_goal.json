[
  {
    "signature": "java.util.concurrent.atomic.AtomicReferenceArray(int length)",
    "name": "java.util.concurrent.atomic.AtomicReferenceArray",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.atomic.AtomicReferenceArray",
      "name": "AtomicReferenceArray",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.atomic.AtomicReferenceArray",
    "isVarArgs": false,
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "length"
      }
    ],
    "protocol": {
      "member": "java.util.concurrent.atomic.AtomicReferenceArray(int length)",
      "comment": "Creates a new AtomicReferenceArray of the given length, with all elements initially null.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "java.util.concurrent.atomic.AtomicReferenceArray(E[] array)",
    "name": "java.util.concurrent.atomic.AtomicReferenceArray",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.atomic.AtomicReferenceArray",
      "name": "AtomicReferenceArray",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.atomic.AtomicReferenceArray",
    "isVarArgs": false,
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "array"
      }
    ],
    "protocol": {
      "member": "java.util.concurrent.atomic.AtomicReferenceArray(E[] array)",
      "comment": "Creates a new AtomicReferenceArray with the same length as, and all elements copied from, the given array.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "length()",
    "name": "length",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.atomic.AtomicReferenceArray",
      "name": "AtomicReferenceArray",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.atomic.AtomicReferenceArray",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "length()",
      "comment": "Returns the length of the array.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "get(int i)",
    "name": "get",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.atomic.AtomicReferenceArray",
      "name": "AtomicReferenceArray",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.atomic.AtomicReferenceArray",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "E",
      "name": "E",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "i"
      }
    ],
    "protocol": {
      "member": "get(int i)",
      "comment": "Gets the current value at position i.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "set(int i, E newValue)",
    "name": "set",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.atomic.AtomicReferenceArray",
      "name": "AtomicReferenceArray",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.atomic.AtomicReferenceArray",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "i"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "newValue"
      }
    ],
    "protocol": {
      "member": "set(int i, E newValue)",
      "comment": "Sets the element at position i to the given value.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "lazySet(int i, E newValue)",
    "name": "lazySet",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.atomic.AtomicReferenceArray",
      "name": "AtomicReferenceArray",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.atomic.AtomicReferenceArray",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "i"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "newValue"
      }
    ],
    "protocol": {
      "member": "lazySet(int i, E newValue)",
      "comment": "Eventually sets the element at position i to the given value.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getAndSet(int i, E newValue)",
    "name": "getAndSet",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.atomic.AtomicReferenceArray",
      "name": "AtomicReferenceArray",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.atomic.AtomicReferenceArray",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "E",
      "name": "E",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "i"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "newValue"
      }
    ],
    "protocol": {
      "member": "getAndSet(int i, E newValue)",
      "comment": "Atomically sets the element at position i to the given value and returns the old value.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "compareAndSet(int i, E expect, E update)",
    "name": "compareAndSet",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.atomic.AtomicReferenceArray",
      "name": "AtomicReferenceArray",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.atomic.AtomicReferenceArray",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "i"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "expect"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "update"
      }
    ],
    "protocol": {
      "member": "compareAndSet(int i, E expect, E update)",
      "comment": "Atomically sets the element at position i to the given updated value if the current value == the expected value.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "weakCompareAndSet(int i, E expect, E update)",
    "name": "weakCompareAndSet",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.atomic.AtomicReferenceArray",
      "name": "AtomicReferenceArray",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.atomic.AtomicReferenceArray",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "i"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "expect"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "update"
      }
    ],
    "protocol": {
      "member": "weakCompareAndSet(int i, E expect, E update)",
      "comment": "Atomically sets the element at position i to the given updated value if the current value == the expected value. May fail spuriously and does not provide ordering guarantees, so is only rarely an appropriate alternative to compareAndSet.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getAndUpdate(int i, java.util.function.UnaryOperator<E> updateFunction)",
    "name": "getAndUpdate",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.atomic.AtomicReferenceArray",
      "name": "AtomicReferenceArray",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.atomic.AtomicReferenceArray",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "E",
      "name": "E",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "i"
      },
      {
        "type": {
          "qualifiedName": "java.util.function.UnaryOperator",
          "name": "UnaryOperator",
          "isArray": false
        },
        "name": "updateFunction"
      }
    ],
    "protocol": {
      "member": "getAndUpdate(int i, java.util.function.UnaryOperator<E> updateFunction)",
      "comment": "Atomically updates the element at index i with the results of applying the given function, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "updateAndGet(int i, java.util.function.UnaryOperator<E> updateFunction)",
    "name": "updateAndGet",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.atomic.AtomicReferenceArray",
      "name": "AtomicReferenceArray",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.atomic.AtomicReferenceArray",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "E",
      "name": "E",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "i"
      },
      {
        "type": {
          "qualifiedName": "java.util.function.UnaryOperator",
          "name": "UnaryOperator",
          "isArray": false
        },
        "name": "updateFunction"
      }
    ],
    "protocol": {
      "member": "updateAndGet(int i, java.util.function.UnaryOperator<E> updateFunction)",
      "comment": "Atomically updates the element at index i with the results of applying the given function, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getAndAccumulate(int i, E x, java.util.function.BinaryOperator<E> accumulatorFunction)",
    "name": "getAndAccumulate",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.atomic.AtomicReferenceArray",
      "name": "AtomicReferenceArray",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.atomic.AtomicReferenceArray",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "E",
      "name": "E",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "i"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "x"
      },
      {
        "type": {
          "qualifiedName": "java.util.function.BinaryOperator",
          "name": "BinaryOperator",
          "isArray": false
        },
        "name": "accumulatorFunction"
      }
    ],
    "protocol": {
      "member": "getAndAccumulate(int i, E x, java.util.function.BinaryOperator<E> accumulatorFunction)",
      "comment": "Atomically updates the element at index i with the results of applying the given function to the current and given values, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads. The function is applied with the current value at index i as its first argument, and the given update as the second argument.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "accumulateAndGet(int i, E x, java.util.function.BinaryOperator<E> accumulatorFunction)",
    "name": "accumulateAndGet",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.atomic.AtomicReferenceArray",
      "name": "AtomicReferenceArray",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.atomic.AtomicReferenceArray",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "E",
      "name": "E",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "i"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "x"
      },
      {
        "type": {
          "qualifiedName": "java.util.function.BinaryOperator",
          "name": "BinaryOperator",
          "isArray": false
        },
        "name": "accumulatorFunction"
      }
    ],
    "protocol": {
      "member": "accumulateAndGet(int i, E x, java.util.function.BinaryOperator<E> accumulatorFunction)",
      "comment": "Atomically updates the element at index i with the results of applying the given function to the current and given values, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads. The function is applied with the current value at index i as its first argument, and the given update as the second argument.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "toString()",
    "name": "toString",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.atomic.AtomicReferenceArray",
      "name": "AtomicReferenceArray",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.atomic.AtomicReferenceArray",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.lang.String",
      "name": "java.lang.String",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "toString()",
      "comment": "Returns the String representation of the current values of array.",
      "kind": "FreeText",
      "condition": ""
    }
  }
]