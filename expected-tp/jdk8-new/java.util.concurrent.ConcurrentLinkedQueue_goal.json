[
  {
    "signature": "java.util.concurrent.ConcurrentLinkedQueue()",
    "name": "java.util.concurrent.ConcurrentLinkedQueue",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ConcurrentLinkedQueue",
      "name": "ConcurrentLinkedQueue",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ConcurrentLinkedQueue",
    "isVarArgs": false,
    "parameters": [],
    "protocol": {
      "member": "java.util.concurrent.ConcurrentLinkedQueue()",
      "comment": "Creates a ConcurrentLinkedQueue that is initially empty.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "java.util.concurrent.ConcurrentLinkedQueue(java.util.Collection<? extends E> c)",
    "name": "java.util.concurrent.ConcurrentLinkedQueue",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ConcurrentLinkedQueue",
      "name": "ConcurrentLinkedQueue",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ConcurrentLinkedQueue",
    "isVarArgs": false,
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Collection",
          "name": "Collection",
          "isArray": false
        },
        "name": "c"
      }
    ],
    "protocol": {
      "member": "java.util.concurrent.ConcurrentLinkedQueue(java.util.Collection<? extends E> c)",
      "comment": "Creates a ConcurrentLinkedQueue initially containing the elements of the given collection, added in traversal order of the collection's iterator.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "add(E e)",
    "name": "add",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ConcurrentLinkedQueue",
      "name": "ConcurrentLinkedQueue",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ConcurrentLinkedQueue",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "e"
      }
    ],
    "protocol": {
      "member": "add(E e)",
      "comment": "Inserts the specified element at the tail of this queue. As the queue is unbounded, this method will never throw IllegalStateException or return false.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "updateHead(java.util.concurrent.ConcurrentLinkedQueue$Node<E> h, java.util.concurrent.ConcurrentLinkedQueue$Node<E> p)",
    "name": "updateHead",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ConcurrentLinkedQueue",
      "name": "ConcurrentLinkedQueue",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ConcurrentLinkedQueue",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.concurrent.ConcurrentLinkedQueue$Node",
          "name": "Node",
          "isArray": false
        },
        "name": "h"
      },
      {
        "type": {
          "qualifiedName": "java.util.concurrent.ConcurrentLinkedQueue$Node",
          "name": "Node",
          "isArray": false
        },
        "name": "p"
      }
    ],
    "protocol": {
      "member": "updateHead(java.util.concurrent.ConcurrentLinkedQueue$Node<E> h, java.util.concurrent.ConcurrentLinkedQueue$Node<E> p)",
      "comment": "Tries to CAS head to p. If successful, repoint old head to itself as sentinel for method_0, below.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "succ(java.util.concurrent.ConcurrentLinkedQueue$Node<E> p)",
    "name": "succ",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ConcurrentLinkedQueue",
      "name": "ConcurrentLinkedQueue",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ConcurrentLinkedQueue",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.concurrent.ConcurrentLinkedQueue$Node<E>",
      "name": "java.util.concurrent.ConcurrentLinkedQueue$Node<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.concurrent.ConcurrentLinkedQueue$Node",
          "name": "Node",
          "isArray": false
        },
        "name": "p"
      }
    ],
    "protocol": {
      "member": "succ(java.util.concurrent.ConcurrentLinkedQueue$Node<E> p)",
      "comment": "Returns the successor of p, or the head node if pmethod_0 has been linked to self, which will only be true if traversing with a stale pointer that is now off the list.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "offer(E e)",
    "name": "offer",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ConcurrentLinkedQueue",
      "name": "ConcurrentLinkedQueue",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ConcurrentLinkedQueue",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "e"
      }
    ],
    "protocol": {
      "member": "offer(E e)",
      "comment": "Inserts the specified element at the tail of this queue. As the queue is unbounded, this method will never return false.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "poll()",
    "name": "poll",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ConcurrentLinkedQueue",
      "name": "ConcurrentLinkedQueue",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ConcurrentLinkedQueue",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "E",
      "name": "E",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "poll()",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "peek()",
    "name": "peek",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ConcurrentLinkedQueue",
      "name": "ConcurrentLinkedQueue",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ConcurrentLinkedQueue",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "E",
      "name": "E",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "peek()",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "first()",
    "name": "first",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ConcurrentLinkedQueue",
      "name": "ConcurrentLinkedQueue",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ConcurrentLinkedQueue",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.concurrent.ConcurrentLinkedQueue$Node<E>",
      "name": "java.util.concurrent.ConcurrentLinkedQueue$Node<E>",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "first()",
      "comment": "Returns the first live (non-deleted) node on list, or null if none. This is yet another variant of poll/peek; here returning the first node, not element. We could make method_0 a wrapper around method_1, but that would cost an extra volatile read of item, and the need to add a retry loop to deal with the possibility of losing a race to a concurrent method_2",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "isEmpty()",
    "name": "isEmpty",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ConcurrentLinkedQueue",
      "name": "ConcurrentLinkedQueue",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ConcurrentLinkedQueue",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "isEmpty()",
      "comment": "Returns true if this queue contains no elements.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "size()",
    "name": "size",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ConcurrentLinkedQueue",
      "name": "ConcurrentLinkedQueue",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ConcurrentLinkedQueue",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "size()",
      "comment": "Returns the number of elements in this queue. If this queue contains more than method_1 elements, returns method_1. Beware that, unlike in most collections, this method is NOT a constant-time operation. Because of the asynchronous nature of these queues, determining the current number of elements requires an method_0 traversal. Additionally, if elements are added or removed during execution of this method, the returned result may be inaccurate. Thus, this method is typically not very useful in concurrent applications.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "contains(java.lang.Object o)",
    "name": "contains",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ConcurrentLinkedQueue",
      "name": "ConcurrentLinkedQueue",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ConcurrentLinkedQueue",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "o"
      }
    ],
    "protocol": {
      "member": "contains(java.lang.Object o)",
      "comment": "Returns true if this queue contains the specified element. More formally, returns true if and only if this queue contains at least one element e such that method_0.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "remove(java.lang.Object o)",
    "name": "remove",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ConcurrentLinkedQueue",
      "name": "ConcurrentLinkedQueue",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ConcurrentLinkedQueue",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "o"
      }
    ],
    "protocol": {
      "member": "remove(java.lang.Object o)",
      "comment": "Removes a single instance of the specified element from this queue, if it is present. More formally, removes an element e such that method_0, if this queue contains one or more such elements. Returns true if this queue contained the specified element (or equivalently, if this queue changed as a result of the call).",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "addAll(java.util.Collection<? extends E> c)",
    "name": "addAll",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ConcurrentLinkedQueue",
      "name": "ConcurrentLinkedQueue",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ConcurrentLinkedQueue",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Collection",
          "name": "Collection",
          "isArray": false
        },
        "name": "c"
      }
    ],
    "protocol": {
      "member": "addAll(java.util.Collection<? extends E> c)",
      "comment": "Appends all of the elements in the specified collection to the end of this queue, in the order that they are returned by the specified collection's iterator. Attempts to addAll of a queue to itself result in IllegalArgumentException.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "toArray()",
    "name": "toArray",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ConcurrentLinkedQueue",
      "name": "ConcurrentLinkedQueue",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ConcurrentLinkedQueue",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.lang.Object[]",
      "name": "java.lang.Object[]",
      "isArray": true
    },
    "parameters": [],
    "protocol": {
      "member": "toArray()",
      "comment": "Returns an array containing all of the elements in this queue, in proper sequence. The returned array will be \"safe\" in that no references to it are maintained by this queue. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "toArray(T[] a)",
    "name": "toArray",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ConcurrentLinkedQueue",
      "name": "ConcurrentLinkedQueue",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ConcurrentLinkedQueue",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "T[]",
      "name": "T[]",
      "isArray": true
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "toArray(T[] a)",
      "comment": "Returns an array containing all of the elements in this queue, in proper sequence; the runtime type of the returned array is that of the specified array. If the queue fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this queue. If this queue fits in the specified array with room to spare (imethod_4., the array has more elements than this queue), the element in the array immediately following the end of the queue is set to null. Like the method_0 method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a queue known to contain only strings. The following code can be used to dump the queue into a newly allocated array of String}:  {@code String[] y = method_1; Note that method_2 is identical in function to method_0.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "iterator()",
    "name": "iterator",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ConcurrentLinkedQueue",
      "name": "ConcurrentLinkedQueue",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ConcurrentLinkedQueue",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.Iterator<E>",
      "name": "java.util.Iterator<E>",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "iterator()",
      "comment": "Returns an iterator over the elements in this queue in proper sequence. The elements will be returned in order from first (head) to last (tail). The returned iterator is <i>weakly consistent</i>.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "spliterator()",
    "name": "spliterator",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ConcurrentLinkedQueue",
      "name": "ConcurrentLinkedQueue",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ConcurrentLinkedQueue",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.Spliterator<E>",
      "name": "java.util.Spliterator<E>",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "spliterator()",
      "comment": "Returns a Spliterator over the elements in this queue. The returned spliterator is <i>weakly consistent</i>. The Spliterator reports method_2, method_3, and method_4. @implNote The Spliterator implements trySplit to permit limited parallelism.",
      "kind": "FreeText",
      "condition": ""
    }
  }
]