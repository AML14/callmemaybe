[
  {
    "signature": "java.util.concurrent.ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, java.util.concurrent.TimeUnit unit, java.util.concurrent.BlockingQueue<java.lang.Runnable> workQueue)",
    "name": "java.util.concurrent.ThreadPoolExecutor",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "corePoolSize"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "maximumPoolSize"
      },
      {
        "type": {
          "qualifiedName": "long",
          "name": "long",
          "isArray": false
        },
        "name": "keepAliveTime"
      },
      {
        "type": {
          "qualifiedName": "java.util.concurrent.TimeUnit",
          "name": "TimeUnit",
          "isArray": false
        },
        "name": "unit"
      },
      {
        "type": {
          "qualifiedName": "java.util.concurrent.BlockingQueue",
          "name": "BlockingQueue",
          "isArray": false
        },
        "name": "workQueue"
      }
    ],
    "protocol": {
      "member": "java.util.concurrent.ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, java.util.concurrent.TimeUnit unit, java.util.concurrent.BlockingQueue<java.lang.Runnable> workQueue)",
      "comment": "Creates a new ThreadPoolExecutor with the given initial parameters and default thread factory and rejected execution handler. It may be more convenient to use one of the Executors factory methods instead of this general purpose constructor.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "java.util.concurrent.ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, java.util.concurrent.TimeUnit unit, java.util.concurrent.BlockingQueue<java.lang.Runnable> workQueue, java.util.concurrent.ThreadFactory threadFactory)",
    "name": "java.util.concurrent.ThreadPoolExecutor",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "corePoolSize"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "maximumPoolSize"
      },
      {
        "type": {
          "qualifiedName": "long",
          "name": "long",
          "isArray": false
        },
        "name": "keepAliveTime"
      },
      {
        "type": {
          "qualifiedName": "java.util.concurrent.TimeUnit",
          "name": "TimeUnit",
          "isArray": false
        },
        "name": "unit"
      },
      {
        "type": {
          "qualifiedName": "java.util.concurrent.BlockingQueue",
          "name": "BlockingQueue",
          "isArray": false
        },
        "name": "workQueue"
      },
      {
        "type": {
          "qualifiedName": "java.util.concurrent.ThreadFactory",
          "name": "ThreadFactory",
          "isArray": false
        },
        "name": "threadFactory"
      }
    ],
    "protocol": {
      "member": "java.util.concurrent.ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, java.util.concurrent.TimeUnit unit, java.util.concurrent.BlockingQueue<java.lang.Runnable> workQueue, java.util.concurrent.ThreadFactory threadFactory)",
      "comment": "Creates a new ThreadPoolExecutor with the given initial parameters and default rejected execution handler.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "java.util.concurrent.ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, java.util.concurrent.TimeUnit unit, java.util.concurrent.BlockingQueue<java.lang.Runnable> workQueue, java.util.concurrent.RejectedExecutionHandler handler)",
    "name": "java.util.concurrent.ThreadPoolExecutor",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "corePoolSize"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "maximumPoolSize"
      },
      {
        "type": {
          "qualifiedName": "long",
          "name": "long",
          "isArray": false
        },
        "name": "keepAliveTime"
      },
      {
        "type": {
          "qualifiedName": "java.util.concurrent.TimeUnit",
          "name": "TimeUnit",
          "isArray": false
        },
        "name": "unit"
      },
      {
        "type": {
          "qualifiedName": "java.util.concurrent.BlockingQueue",
          "name": "BlockingQueue",
          "isArray": false
        },
        "name": "workQueue"
      },
      {
        "type": {
          "qualifiedName": "java.util.concurrent.RejectedExecutionHandler",
          "name": "RejectedExecutionHandler",
          "isArray": false
        },
        "name": "handler"
      }
    ],
    "protocol": {
      "member": "java.util.concurrent.ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, java.util.concurrent.TimeUnit unit, java.util.concurrent.BlockingQueue<java.lang.Runnable> workQueue, java.util.concurrent.RejectedExecutionHandler handler)",
      "comment": "Creates a new ThreadPoolExecutor with the given initial parameters and default thread factory.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "java.util.concurrent.ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, java.util.concurrent.TimeUnit unit, java.util.concurrent.BlockingQueue<java.lang.Runnable> workQueue, java.util.concurrent.ThreadFactory threadFactory, java.util.concurrent.RejectedExecutionHandler handler)",
    "name": "java.util.concurrent.ThreadPoolExecutor",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "corePoolSize"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "maximumPoolSize"
      },
      {
        "type": {
          "qualifiedName": "long",
          "name": "long",
          "isArray": false
        },
        "name": "keepAliveTime"
      },
      {
        "type": {
          "qualifiedName": "java.util.concurrent.TimeUnit",
          "name": "TimeUnit",
          "isArray": false
        },
        "name": "unit"
      },
      {
        "type": {
          "qualifiedName": "java.util.concurrent.BlockingQueue",
          "name": "BlockingQueue",
          "isArray": false
        },
        "name": "workQueue"
      },
      {
        "type": {
          "qualifiedName": "java.util.concurrent.ThreadFactory",
          "name": "ThreadFactory",
          "isArray": false
        },
        "name": "threadFactory"
      },
      {
        "type": {
          "qualifiedName": "java.util.concurrent.RejectedExecutionHandler",
          "name": "RejectedExecutionHandler",
          "isArray": false
        },
        "name": "handler"
      }
    ],
    "protocol": {
      "member": "java.util.concurrent.ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, java.util.concurrent.TimeUnit unit, java.util.concurrent.BlockingQueue<java.lang.Runnable> workQueue, java.util.concurrent.ThreadFactory threadFactory, java.util.concurrent.RejectedExecutionHandler handler)",
      "comment": "Creates a new ThreadPoolExecutor with the given initial parameters.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "tryTerminate()",
    "name": "tryTerminate",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "tryTerminate()",
      "comment": "Transitions to TERMINATED state if either (SHUTDOWN and pool and queue empty) or (STOP and pool empty). If otherwise eligible to terminate but workerCount is nonzero, interrupts an idle worker to ensure that shutdown signals propagate. This method must be called following any action that might make termination possible -- reducing worker count or removing tasks from the queue during shutdown. The method is non-private to allow access from ScheduledThreadPoolExecutor.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "reject(java.lang.Runnable command)",
    "name": "reject",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Runnable",
          "name": "Runnable",
          "isArray": false
        },
        "name": "command"
      }
    ],
    "protocol": {
      "member": "reject(java.lang.Runnable command)",
      "comment": "Invokes the rejected execution handler for the given command. Package-protected for use by ScheduledThreadPoolExecutor.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "onShutdown()",
    "name": "onShutdown",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "onShutdown()",
      "comment": "Performs any further cleanup following run state transition on invocation of shutdown. A no-op here, but used by ScheduledThreadPoolExecutor to cancel delayed tasks.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "isRunningOrShutdown(boolean shutdownOK)",
    "name": "isRunningOrShutdown",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "boolean",
          "name": "boolean",
          "isArray": false
        },
        "name": "shutdownOK"
      }
    ],
    "protocol": {
      "member": "isRunningOrShutdown(boolean shutdownOK)",
      "comment": "State check needed by ScheduledThreadPoolExecutor to enable running tasks during shutdown.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "runWorker(java.util.concurrent.ThreadPoolExecutor$Worker w)",
    "name": "runWorker",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.concurrent.ThreadPoolExecutor$Worker",
          "name": "Worker",
          "isArray": false
        },
        "name": "w"
      }
    ],
    "protocol": {
      "member": "runWorker(java.util.concurrent.ThreadPoolExecutor$Worker w)",
      "comment": "Main worker run loop. Repeatedly gets tasks from queue and executes them, while coping with a number of issues: 1. We may start out with an initial task, in which case we don't need to get the first one. Otherwise, as long as pool is running, we get tasks from getTask. If it returns null then the worker exits due to changed pool state or configuration parameters. Other exits result from exception throws in external code, in which case completedAbruptly holds, which usually leads processWorkerExit to replace this thread. 2. Before running any task, the lock is acquired to prevent other pool interrupts while the task is executing, and then we ensure that unless pool is stopping, this thread does not have its interrupt set. 3. Each task run is preceded by a call to beforeExecute, which might throw an exception, in which case we cause thread to die (breaking loop with completedAbruptly true) without processing the task. 4. Assuming beforeExecute completes normally, we run the task, gathering any of its thrown exceptions to send to afterExecute. We separately handle RuntimeException, Error (both of which the specs guarantee that we trap) and arbitrary Throwables. Because we cannot rethrow Throwables within method_0, we wrap them within Errors on the way out (to the thread's UncaughtExceptionHandler). Any thrown exception also conservatively causes thread to die. 5. After taskmethod_1 completes, we call afterExecute, which may also throw an exception, which will also cause thread to die. According to JLS Sec 14method_2, this exception is the one that will be in effect even if taskmethod_1 throws. The net effect of the exception mechanics is that afterExecute and the thread's UncaughtExceptionHandler have as accurate information as we can provide about any problems encountered by user code.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "execute(java.lang.Runnable command)",
    "name": "execute",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Runnable",
          "name": "Runnable",
          "isArray": false
        },
        "name": "command"
      }
    ],
    "protocol": {
      "member": "execute(java.lang.Runnable command)",
      "comment": "Executes the given task sometime in the future. The task may execute in a new thread or in an existing pooled thread. If the task cannot be submitted for execution, either because this executor has been shutdown or because its capacity has been reached, the task is handled by the current RejectedExecutionHandler.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "shutdown()",
    "name": "shutdown",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "shutdown()",
      "comment": "Initiates an orderly shutdown in which previously submitted tasks are executed, but no new tasks will be accepted. Invocation has no additional effect if already shut down. This method does not wait for previously submitted tasks to complete execution. Use method_0 awaitTermination to do that.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "shutdownNow()",
    "name": "shutdownNow",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.List<java.lang.Runnable>",
      "name": "java.util.List<java.lang.Runnable>",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "shutdownNow()",
      "comment": "Attempts to stop all actively executing tasks, halts the processing of waiting tasks, and returns a list of the tasks that were awaiting execution. These tasks are drained (removed) from the task queue upon return from this method. This method does not wait for actively executing tasks to terminate. Use method_0 awaitTermination to do that. There are no guarantees beyond best-effort attempts to stop processing actively executing tasks. This implementation cancels tasks via method_1, so any task that fails to respond to interrupts may never terminate.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "isShutdown()",
    "name": "isShutdown",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "isShutdown()",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "isTerminating()",
    "name": "isTerminating",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "isTerminating()",
      "comment": "Returns true if this executor is in the process of terminating after method_0 or method_0Now but has not completely terminated. This method may be useful for debugging. A return of true reported a sufficient period after shutdown may indicate that submitted tasks have ignored or suppressed interruption, causing this executor not to properly terminate.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "isTerminated()",
    "name": "isTerminated",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "isTerminated()",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "awaitTermination(long timeout, java.util.concurrent.TimeUnit unit)",
    "name": "awaitTermination",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "long",
          "name": "long",
          "isArray": false
        },
        "name": "timeout"
      },
      {
        "type": {
          "qualifiedName": "java.util.concurrent.TimeUnit",
          "name": "TimeUnit",
          "isArray": false
        },
        "name": "unit"
      }
    ],
    "protocol": {
      "member": "awaitTermination(long timeout, java.util.concurrent.TimeUnit unit)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "finalize()",
    "name": "finalize",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "finalize()",
      "comment": "Invokes shutdown when this executor is no longer referenced and it has no threads.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "setThreadFactory(java.util.concurrent.ThreadFactory threadFactory)",
    "name": "setThreadFactory",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.concurrent.ThreadFactory",
          "name": "ThreadFactory",
          "isArray": false
        },
        "name": "threadFactory"
      }
    ],
    "protocol": {
      "member": "setThreadFactory(java.util.concurrent.ThreadFactory threadFactory)",
      "comment": "Sets the thread factory used to create new threads.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getThreadFactory()",
    "name": "getThreadFactory",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.concurrent.ThreadFactory",
      "name": "java.util.concurrent.ThreadFactory",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getThreadFactory()",
      "comment": "Returns the thread factory used to create new threads.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "setRejectedExecutionHandler(java.util.concurrent.RejectedExecutionHandler handler)",
    "name": "setRejectedExecutionHandler",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.concurrent.RejectedExecutionHandler",
          "name": "RejectedExecutionHandler",
          "isArray": false
        },
        "name": "handler"
      }
    ],
    "protocol": {
      "member": "setRejectedExecutionHandler(java.util.concurrent.RejectedExecutionHandler handler)",
      "comment": "Sets a new handler for unexecutable tasks.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getRejectedExecutionHandler()",
    "name": "getRejectedExecutionHandler",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.concurrent.RejectedExecutionHandler",
      "name": "java.util.concurrent.RejectedExecutionHandler",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getRejectedExecutionHandler()",
      "comment": "Returns the current handler for unexecutable tasks.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "setCorePoolSize(int corePoolSize)",
    "name": "setCorePoolSize",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "corePoolSize"
      }
    ],
    "protocol": {
      "member": "setCorePoolSize(int corePoolSize)",
      "comment": "Sets the core number of threads. This overrides any value set in the constructor. If the new value is smaller than the current value, excess existing threads will be terminated when they next become idle. If larger, new threads will, if needed, be started to execute any queued tasks.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getCorePoolSize()",
    "name": "getCorePoolSize",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getCorePoolSize()",
      "comment": "Returns the core number of threads.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "prestartCoreThread()",
    "name": "prestartCoreThread",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "prestartCoreThread()",
      "comment": "Starts a core thread, causing it to idly wait for work. This overrides the default policy of starting core threads only when new tasks are executed. This method will return false if all core threads have already been started.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "ensurePrestart()",
    "name": "ensurePrestart",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "ensurePrestart()",
      "comment": "Same as prestartCoreThread except arranges that at least one thread is started even if corePoolSize is 0.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "prestartAllCoreThreads()",
    "name": "prestartAllCoreThreads",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "prestartAllCoreThreads()",
      "comment": "Starts all core threads, causing them to idly wait for work. This overrides the default policy of starting core threads only when new tasks are executed.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "allowsCoreThreadTimeOut()",
    "name": "allowsCoreThreadTimeOut",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "allowsCoreThreadTimeOut()",
      "comment": "Returns true if this pool allows core threads to time out and terminate if no tasks arrive within the keepAlive time, being replaced if needed when new tasks arrive. When true, the same keep-alive policy applying to non-core threads applies also to core threads. When false (the default), core threads are never terminated due to lack of incoming tasks.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "allowCoreThreadTimeOut(boolean value)",
    "name": "allowCoreThreadTimeOut",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "boolean",
          "name": "boolean",
          "isArray": false
        },
        "name": "value"
      }
    ],
    "protocol": {
      "member": "allowCoreThreadTimeOut(boolean value)",
      "comment": "Sets the policy governing whether core threads may time out and terminate if no tasks arrive within the keep-alive time, being replaced if needed when new tasks arrive. When false, core threads are never terminated due to lack of incoming tasks. When true, the same keep-alive policy applying to non-core threads applies also to core threads. To avoid continual thread replacement, the keep-alive time must be greater than zero when setting true. This method should in general be called before the pool is actively used.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "setMaximumPoolSize(int maximumPoolSize)",
    "name": "setMaximumPoolSize",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "maximumPoolSize"
      }
    ],
    "protocol": {
      "member": "setMaximumPoolSize(int maximumPoolSize)",
      "comment": "Sets the maximum allowed number of threads. This overrides any value set in the constructor. If the new value is smaller than the current value, excess existing threads will be terminated when they next become idle.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getMaximumPoolSize()",
    "name": "getMaximumPoolSize",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getMaximumPoolSize()",
      "comment": "Returns the maximum allowed number of threads.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "setKeepAliveTime(long time, java.util.concurrent.TimeUnit unit)",
    "name": "setKeepAliveTime",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "long",
          "name": "long",
          "isArray": false
        },
        "name": "time"
      },
      {
        "type": {
          "qualifiedName": "java.util.concurrent.TimeUnit",
          "name": "TimeUnit",
          "isArray": false
        },
        "name": "unit"
      }
    ],
    "protocol": {
      "member": "setKeepAliveTime(long time, java.util.concurrent.TimeUnit unit)",
      "comment": "Sets the time limit for which threads may remain idle before being terminated. If there are more than the core number of threads currently in the pool, after waiting this amount of time without processing a task, excess threads will be terminated. This overrides any value set in the constructor.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getKeepAliveTime(java.util.concurrent.TimeUnit unit)",
    "name": "getKeepAliveTime",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "long",
      "name": "long",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.concurrent.TimeUnit",
          "name": "TimeUnit",
          "isArray": false
        },
        "name": "unit"
      }
    ],
    "protocol": {
      "member": "getKeepAliveTime(java.util.concurrent.TimeUnit unit)",
      "comment": "Returns the thread keep-alive time, which is the amount of time that threads in excess of the core pool size may remain idle before being terminated.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getQueue()",
    "name": "getQueue",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.concurrent.BlockingQueue<java.lang.Runnable>",
      "name": "java.util.concurrent.BlockingQueue<java.lang.Runnable>",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getQueue()",
      "comment": "Returns the task queue used by this executor. Access to the task queue is intended primarily for debugging and monitoring. This queue may be in active use. Retrieving the task queue does not prevent queued tasks from executing.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "remove(java.lang.Runnable task)",
    "name": "remove",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Runnable",
          "name": "Runnable",
          "isArray": false
        },
        "name": "task"
      }
    ],
    "protocol": {
      "member": "remove(java.lang.Runnable task)",
      "comment": "Removes this task from the executor's internal queue if it is present, thus causing it not to be run if it has not already started. This method may be useful as one part of a cancellation scheme. It may fail to remove tasks that have been converted into other forms before being placed on the internal queue. For example, a task entered using submit might be converted into a form that maintains Future status. However, in such cases, method method_0 may be used to remove those Futures that have been cancelled.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "purge()",
    "name": "purge",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "purge()",
      "comment": "Tries to remove from the work queue all Future tasks that have been cancelled. This method can be useful as a storage reclamation operation, that has no other impact on functionality. Cancelled tasks are never executed, but may accumulate in work queues until worker threads can actively remove them. Invoking this method instead tries to remove them now. However, this method may fail to remove tasks in the presence of interference by other threads.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getPoolSize()",
    "name": "getPoolSize",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getPoolSize()",
      "comment": "Returns the current number of threads in the pool.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getActiveCount()",
    "name": "getActiveCount",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getActiveCount()",
      "comment": "Returns the approximate number of threads that are actively executing tasks.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getLargestPoolSize()",
    "name": "getLargestPoolSize",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getLargestPoolSize()",
      "comment": "Returns the largest number of threads that have ever simultaneously been in the pool.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getTaskCount()",
    "name": "getTaskCount",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "long",
      "name": "long",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getTaskCount()",
      "comment": "Returns the approximate total number of tasks that have ever been scheduled for execution. Because the states of tasks and threads may change dynamically during computation, the returned value is only an approximation.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getCompletedTaskCount()",
    "name": "getCompletedTaskCount",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "long",
      "name": "long",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getCompletedTaskCount()",
      "comment": "Returns the approximate total number of tasks that have completed execution. Because the states of tasks and threads may change dynamically during computation, the returned value is only an approximation, but one that does not ever decrease across successive calls.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "toString()",
    "name": "toString",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.lang.String",
      "name": "java.lang.String",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "toString()",
      "comment": "Returns a string identifying this pool, as well as its state, including indications of run state and estimated worker and task counts.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "beforeExecute(java.lang.Thread t, java.lang.Runnable r)",
    "name": "beforeExecute",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Thread",
          "name": "Thread",
          "isArray": false
        },
        "name": "t"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Runnable",
          "name": "Runnable",
          "isArray": false
        },
        "name": "r"
      }
    ],
    "protocol": {
      "member": "beforeExecute(java.lang.Thread t, java.lang.Runnable r)",
      "comment": "Method invoked prior to executing the given Runnable in the given thread. This method is invoked by thread t that will execute task r, and may be used to re-initialize ThreadLocals, or to perform logging. This implementation does nothing, but may be customized in subclasses. Note: To properly nest multiple overridings, subclasses should generally invoke supermethod_0 at the end of this method.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "afterExecute(java.lang.Runnable r, java.lang.Throwable t)",
    "name": "afterExecute",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Runnable",
          "name": "Runnable",
          "isArray": false
        },
        "name": "r"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Throwable",
          "name": "Throwable",
          "isArray": false
        },
        "name": "t"
      }
    ],
    "protocol": {
      "member": "afterExecute(java.lang.Runnable r, java.lang.Throwable t)",
      "comment": "Method invoked upon completion of execution of the given Runnable. This method is invoked by the thread that executed the task. If non-null, the Throwable is the uncaught RuntimeException or Error that caused execution to terminate abruptly. This implementation does nothing, but may be customized in subclasses. Note: To properly nest multiple overridings, subclasses should generally invoke supermethod_7 at the beginning of this method. Note: When actions are enclosed in tasks (such as FutureTask) either explicitly or via methods such as submit, these task objects catch and maintain computational exceptions, and so they do not cause abrupt termination, and the internal exceptions are not passed to this method. If you would like to trap both kinds of failures in this method, you can further probe for such cases, as in this sample subclass that prints either the direct cause or the underlying exception if a task has been aborted:  class ExtendedExecutor extends ThreadPoolExecutor { // ... protected void method_0 { method_1; if (t == null && r instanceof Future<?>) { try { Object result = ((Future<?>) r).method_2;  catch (CancellationException ce) { t = ce; } catch (ExecutionException ee) { t = method_3; } catch (InterruptedException ie) { method_4method_5; // ignore/reset } } if (t != null) System.method_6; } }}",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "terminated()",
    "name": "terminated",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.ThreadPoolExecutor",
      "name": "ThreadPoolExecutor",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.ThreadPoolExecutor",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "terminated()",
      "comment": "Method invoked when the Executor has terminated. Default implementation does nothing. Note: To properly nest multiple overridings, subclasses should generally invoke supermethod_0 within this method.",
      "kind": "FreeText",
      "condition": ""
    }
  }
]