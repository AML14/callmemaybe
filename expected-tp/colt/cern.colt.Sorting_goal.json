[
  {
    "signature": "cern.colt.Sorting()",
    "name": "cern.colt.Sorting",
    "containingClass": {
      "qualifiedName": "cern.colt.Sorting",
      "name": "Sorting",
      "isArray": false
    },
    "targetClass": "cern.colt.Sorting",
    "isVarArgs": false,
    "parameters": [],
    "protocol": {
      "member": "cern.colt.Sorting()",
      "comment": "Makes this class non instantiable, but still let's others inherit from it.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "binarySearchFromTo(byte[] list, byte key, int from, int to)",
    "name": "binarySearchFromTo",
    "containingClass": {
      "qualifiedName": "cern.colt.Sorting",
      "name": "Sorting",
      "isArray": false
    },
    "targetClass": "cern.colt.Sorting",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[B",
          "name": "byte[]",
          "isArray": true
        },
        "name": "list"
      },
      {
        "type": {
          "qualifiedName": "byte",
          "name": "byte",
          "isArray": false
        },
        "name": "key"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "from"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "to"
      }
    ],
    "protocol": {
      "member": "binarySearchFromTo(byte[] list, byte key, int from, int to)",
      "comment": "Searches the list for the specified value using the binary search algorithm. The list must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the list contains multiple elements equal to the specified key, there is no guarantee which of the multiple elements will be found.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "binarySearchFromTo(char[] list, char key, int from, int to)",
    "name": "binarySearchFromTo",
    "containingClass": {
      "qualifiedName": "cern.colt.Sorting",
      "name": "Sorting",
      "isArray": false
    },
    "targetClass": "cern.colt.Sorting",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[C",
          "name": "char[]",
          "isArray": true
        },
        "name": "list"
      },
      {
        "type": {
          "qualifiedName": "char",
          "name": "char",
          "isArray": false
        },
        "name": "key"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "from"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "to"
      }
    ],
    "protocol": {
      "member": "binarySearchFromTo(char[] list, char key, int from, int to)",
      "comment": "Searches the list for the specified value using the binary search algorithm. The list must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the list contains multiple elements equal to the specified key, there is no guarantee which of the multiple elements will be found.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "binarySearchFromTo(double[] list, double key, int from, int to)",
    "name": "binarySearchFromTo",
    "containingClass": {
      "qualifiedName": "cern.colt.Sorting",
      "name": "Sorting",
      "isArray": false
    },
    "targetClass": "cern.colt.Sorting",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "list"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "key"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "from"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "to"
      }
    ],
    "protocol": {
      "member": "binarySearchFromTo(double[] list, double key, int from, int to)",
      "comment": "Searches the list for the specified value using the binary search algorithm. The list must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the list contains multiple elements equal to the specified key, there is no guarantee which of the multiple elements will be found.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "binarySearchFromTo(float[] list, float key, int from, int to)",
    "name": "binarySearchFromTo",
    "containingClass": {
      "qualifiedName": "cern.colt.Sorting",
      "name": "Sorting",
      "isArray": false
    },
    "targetClass": "cern.colt.Sorting",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[F",
          "name": "float[]",
          "isArray": true
        },
        "name": "list"
      },
      {
        "type": {
          "qualifiedName": "float",
          "name": "float",
          "isArray": false
        },
        "name": "key"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "from"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "to"
      }
    ],
    "protocol": {
      "member": "binarySearchFromTo(float[] list, float key, int from, int to)",
      "comment": "Searches the list for the specified value using the binary search algorithm. The list must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the list contains multiple elements equal to the specified key, there is no guarantee which of the multiple elements will be found.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "binarySearchFromTo(int[] list, int key, int from, int to)",
    "name": "binarySearchFromTo",
    "containingClass": {
      "qualifiedName": "cern.colt.Sorting",
      "name": "Sorting",
      "isArray": false
    },
    "targetClass": "cern.colt.Sorting",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[I",
          "name": "int[]",
          "isArray": true
        },
        "name": "list"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "key"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "from"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "to"
      }
    ],
    "protocol": {
      "member": "binarySearchFromTo(int[] list, int key, int from, int to)",
      "comment": "Searches the list for the specified value using the binary search algorithm. The list must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the list contains multiple elements equal to the specified key, there is no guarantee which of the multiple elements will be found.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "binarySearchFromTo(long[] list, long key, int from, int to)",
    "name": "binarySearchFromTo",
    "containingClass": {
      "qualifiedName": "cern.colt.Sorting",
      "name": "Sorting",
      "isArray": false
    },
    "targetClass": "cern.colt.Sorting",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[J",
          "name": "long[]",
          "isArray": true
        },
        "name": "list"
      },
      {
        "type": {
          "qualifiedName": "long",
          "name": "long",
          "isArray": false
        },
        "name": "key"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "from"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "to"
      }
    ],
    "protocol": {
      "member": "binarySearchFromTo(long[] list, long key, int from, int to)",
      "comment": "Searches the list for the specified value using the binary search algorithm. The list must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the list contains multiple elements equal to the specified key, there is no guarantee which of the multiple elements will be found.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "binarySearchFromTo(java.lang.Object[] list, java.lang.Object key, int from, int to, java.util.Comparator comparator)",
    "name": "binarySearchFromTo",
    "containingClass": {
      "qualifiedName": "cern.colt.Sorting",
      "name": "Sorting",
      "isArray": false
    },
    "targetClass": "cern.colt.Sorting",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "list"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "key"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "from"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "to"
      },
      {
        "type": {
          "qualifiedName": "java.util.Comparator",
          "name": "Comparator",
          "isArray": false
        },
        "name": "comparator"
      }
    ],
    "protocol": {
      "member": "binarySearchFromTo(java.lang.Object[] list, java.lang.Object key, int from, int to, java.util.Comparator comparator)",
      "comment": "Searches the list for the specified value using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator. All elements in the range must be mutually comparable by the specified comparator (that is, method_0 must not throw a ClassCastException for any elements e1 and e2 in the range). If the list is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the list contains multiple elements equal to the specified key, there is no guarantee which instance will be found.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "binarySearchFromTo(short[] list, short key, int from, int to)",
    "name": "binarySearchFromTo",
    "containingClass": {
      "qualifiedName": "cern.colt.Sorting",
      "name": "Sorting",
      "isArray": false
    },
    "targetClass": "cern.colt.Sorting",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[S",
          "name": "short[]",
          "isArray": true
        },
        "name": "list"
      },
      {
        "type": {
          "qualifiedName": "short",
          "name": "short",
          "isArray": false
        },
        "name": "key"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "from"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "to"
      }
    ],
    "protocol": {
      "member": "binarySearchFromTo(short[] list, short key, int from, int to)",
      "comment": "Searches the list for the specified value using the binary search algorithm. The list must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the list contains multiple elements equal to the specified key, there is no guarantee which of the multiple elements will be found.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "binarySearchFromTo(int from, int to, cern.colt.function.IntComparator comp)",
    "name": "binarySearchFromTo",
    "containingClass": {
      "qualifiedName": "cern.colt.Sorting",
      "name": "Sorting",
      "isArray": false
    },
    "targetClass": "cern.colt.Sorting",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "from"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "to"
      },
      {
        "type": {
          "qualifiedName": "cern.colt.function.IntComparator",
          "name": "IntComparator",
          "isArray": false
        },
        "name": "comp"
      }
    ],
    "protocol": {
      "member": "binarySearchFromTo(int from, int to, cern.colt.function.IntComparator comp)",
      "comment": "Generically searches the list for the specified value using the binary search algorithm. The list must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the list contains multiple elements equal to the specified key, there is no guarantee which of the multiple elements will be found.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "mergeSort(byte[] a, int fromIndex, int toIndex)",
    "name": "mergeSort",
    "containingClass": {
      "qualifiedName": "cern.colt.Sorting",
      "name": "Sorting",
      "isArray": false
    },
    "targetClass": "cern.colt.Sorting",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[B",
          "name": "byte[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      }
    ],
    "protocol": {
      "member": "mergeSort(byte[] a, int fromIndex, int toIndex)",
      "comment": "Sorts the specified range of the specified array of elements. This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). This algorithm offers guaranteed n*method_0 performance, and can approach linear performance on nearly sorted lists.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "mergeSort(byte[] a, int fromIndex, int toIndex, cern.colt.function.ByteComparator c)",
    "name": "mergeSort",
    "containingClass": {
      "qualifiedName": "cern.colt.Sorting",
      "name": "Sorting",
      "isArray": false
    },
    "targetClass": "cern.colt.Sorting",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[B",
          "name": "byte[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "cern.colt.function.ByteComparator",
          "name": "ByteComparator",
          "isArray": false
        },
        "name": "c"
      }
    ],
    "protocol": {
      "member": "mergeSort(byte[] a, int fromIndex, int toIndex, cern.colt.function.ByteComparator c)",
      "comment": "Sorts the specified range of the specified array of elements according to the order induced by the specified comparator. All elements in the range must be mutually comparable by the specified comparator (that is, method_0 must not throw a ClassCastException for any elements e1 and e2 in the range). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). This algorithm offers guaranteed n*method_1 performance, and can approach linear performance on nearly sorted lists.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "mergeSort(char[] a, int fromIndex, int toIndex)",
    "name": "mergeSort",
    "containingClass": {
      "qualifiedName": "cern.colt.Sorting",
      "name": "Sorting",
      "isArray": false
    },
    "targetClass": "cern.colt.Sorting",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[C",
          "name": "char[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      }
    ],
    "protocol": {
      "member": "mergeSort(char[] a, int fromIndex, int toIndex)",
      "comment": "Sorts the specified range of the specified array of elements. This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). This algorithm offers guaranteed n*method_0 performance, and can approach linear performance on nearly sorted lists.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "mergeSort(char[] a, int fromIndex, int toIndex, cern.colt.function.CharComparator c)",
    "name": "mergeSort",
    "containingClass": {
      "qualifiedName": "cern.colt.Sorting",
      "name": "Sorting",
      "isArray": false
    },
    "targetClass": "cern.colt.Sorting",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[C",
          "name": "char[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "cern.colt.function.CharComparator",
          "name": "CharComparator",
          "isArray": false
        },
        "name": "c"
      }
    ],
    "protocol": {
      "member": "mergeSort(char[] a, int fromIndex, int toIndex, cern.colt.function.CharComparator c)",
      "comment": "Sorts the specified range of the specified array of elements according to the order induced by the specified comparator. All elements in the range must be mutually comparable by the specified comparator (that is, method_0 must not throw a ClassCastException for any elements e1 and e2 in the range). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). This algorithm offers guaranteed n*method_1 performance, and can approach linear performance on nearly sorted lists.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "mergeSort(double[] a, int fromIndex, int toIndex)",
    "name": "mergeSort",
    "containingClass": {
      "qualifiedName": "cern.colt.Sorting",
      "name": "Sorting",
      "isArray": false
    },
    "targetClass": "cern.colt.Sorting",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      }
    ],
    "protocol": {
      "member": "mergeSort(double[] a, int fromIndex, int toIndex)",
      "comment": "Sorts the specified range of the specified array of elements. This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). This algorithm offers guaranteed n*method_0 performance, and can approach linear performance on nearly sorted lists.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "mergeSort(double[] a, int fromIndex, int toIndex, cern.colt.function.DoubleComparator c)",
    "name": "mergeSort",
    "containingClass": {
      "qualifiedName": "cern.colt.Sorting",
      "name": "Sorting",
      "isArray": false
    },
    "targetClass": "cern.colt.Sorting",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "cern.colt.function.DoubleComparator",
          "name": "DoubleComparator",
          "isArray": false
        },
        "name": "c"
      }
    ],
    "protocol": {
      "member": "mergeSort(double[] a, int fromIndex, int toIndex, cern.colt.function.DoubleComparator c)",
      "comment": "Sorts the specified range of the specified array of elements according to the order induced by the specified comparator. All elements in the range must be mutually comparable by the specified comparator (that is, method_0 must not throw a ClassCastException for any elements e1 and e2 in the range). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). This algorithm offers guaranteed n*method_1 performance, and can approach linear performance on nearly sorted lists.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "mergeSort(float[] a, int fromIndex, int toIndex)",
    "name": "mergeSort",
    "containingClass": {
      "qualifiedName": "cern.colt.Sorting",
      "name": "Sorting",
      "isArray": false
    },
    "targetClass": "cern.colt.Sorting",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[F",
          "name": "float[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      }
    ],
    "protocol": {
      "member": "mergeSort(float[] a, int fromIndex, int toIndex)",
      "comment": "Sorts the specified range of the specified array of elements. This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). This algorithm offers guaranteed n*method_0 performance, and can approach linear performance on nearly sorted lists.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "mergeSort(float[] a, int fromIndex, int toIndex, cern.colt.function.FloatComparator c)",
    "name": "mergeSort",
    "containingClass": {
      "qualifiedName": "cern.colt.Sorting",
      "name": "Sorting",
      "isArray": false
    },
    "targetClass": "cern.colt.Sorting",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[F",
          "name": "float[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "cern.colt.function.FloatComparator",
          "name": "FloatComparator",
          "isArray": false
        },
        "name": "c"
      }
    ],
    "protocol": {
      "member": "mergeSort(float[] a, int fromIndex, int toIndex, cern.colt.function.FloatComparator c)",
      "comment": "Sorts the specified range of the specified array of elements according to the order induced by the specified comparator. All elements in the range must be mutually comparable by the specified comparator (that is, method_0 must not throw a ClassCastException for any elements e1 and e2 in the range). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). This algorithm offers guaranteed n*method_1 performance, and can approach linear performance on nearly sorted lists.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "mergeSort(int[] a, int fromIndex, int toIndex)",
    "name": "mergeSort",
    "containingClass": {
      "qualifiedName": "cern.colt.Sorting",
      "name": "Sorting",
      "isArray": false
    },
    "targetClass": "cern.colt.Sorting",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[I",
          "name": "int[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      }
    ],
    "protocol": {
      "member": "mergeSort(int[] a, int fromIndex, int toIndex)",
      "comment": "Sorts the specified range of the specified array of elements. This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). This algorithm offers guaranteed n*method_0 performance, and can approach linear performance on nearly sorted lists.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "mergeSort(int[] a, int fromIndex, int toIndex, cern.colt.function.IntComparator c)",
    "name": "mergeSort",
    "containingClass": {
      "qualifiedName": "cern.colt.Sorting",
      "name": "Sorting",
      "isArray": false
    },
    "targetClass": "cern.colt.Sorting",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[I",
          "name": "int[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "cern.colt.function.IntComparator",
          "name": "IntComparator",
          "isArray": false
        },
        "name": "c"
      }
    ],
    "protocol": {
      "member": "mergeSort(int[] a, int fromIndex, int toIndex, cern.colt.function.IntComparator c)",
      "comment": "Sorts the specified range of the specified array of elements according to the order induced by the specified comparator. All elements in the range must be mutually comparable by the specified comparator (that is, method_0 must not throw a ClassCastException for any elements e1 and e2 in the range). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). This algorithm offers guaranteed n*method_1 performance, and can approach linear performance on nearly sorted lists.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "mergeSort(long[] a, int fromIndex, int toIndex)",
    "name": "mergeSort",
    "containingClass": {
      "qualifiedName": "cern.colt.Sorting",
      "name": "Sorting",
      "isArray": false
    },
    "targetClass": "cern.colt.Sorting",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[J",
          "name": "long[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      }
    ],
    "protocol": {
      "member": "mergeSort(long[] a, int fromIndex, int toIndex)",
      "comment": "Sorts the specified range of the specified array of elements. This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). This algorithm offers guaranteed n*method_0 performance, and can approach linear performance on nearly sorted lists.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "mergeSort(long[] a, int fromIndex, int toIndex, cern.colt.function.LongComparator c)",
    "name": "mergeSort",
    "containingClass": {
      "qualifiedName": "cern.colt.Sorting",
      "name": "Sorting",
      "isArray": false
    },
    "targetClass": "cern.colt.Sorting",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[J",
          "name": "long[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "cern.colt.function.LongComparator",
          "name": "LongComparator",
          "isArray": false
        },
        "name": "c"
      }
    ],
    "protocol": {
      "member": "mergeSort(long[] a, int fromIndex, int toIndex, cern.colt.function.LongComparator c)",
      "comment": "Sorts the specified range of the specified array of elements according to the order induced by the specified comparator. All elements in the range must be mutually comparable by the specified comparator (that is, method_0 must not throw a ClassCastException for any elements e1 and e2 in the range). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). This algorithm offers guaranteed n*method_1 performance, and can approach linear performance on nearly sorted lists.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "mergeSort(short[] a, int fromIndex, int toIndex)",
    "name": "mergeSort",
    "containingClass": {
      "qualifiedName": "cern.colt.Sorting",
      "name": "Sorting",
      "isArray": false
    },
    "targetClass": "cern.colt.Sorting",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[S",
          "name": "short[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      }
    ],
    "protocol": {
      "member": "mergeSort(short[] a, int fromIndex, int toIndex)",
      "comment": "Sorts the specified range of the specified array of elements. This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). This algorithm offers guaranteed n*method_0 performance, and can approach linear performance on nearly sorted lists.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "mergeSort(short[] a, int fromIndex, int toIndex, cern.colt.function.ShortComparator c)",
    "name": "mergeSort",
    "containingClass": {
      "qualifiedName": "cern.colt.Sorting",
      "name": "Sorting",
      "isArray": false
    },
    "targetClass": "cern.colt.Sorting",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[S",
          "name": "short[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "cern.colt.function.ShortComparator",
          "name": "ShortComparator",
          "isArray": false
        },
        "name": "c"
      }
    ],
    "protocol": {
      "member": "mergeSort(short[] a, int fromIndex, int toIndex, cern.colt.function.ShortComparator c)",
      "comment": "Sorts the specified range of the specified array of elements according to the order induced by the specified comparator. All elements in the range must be mutually comparable by the specified comparator (that is, method_0 must not throw a ClassCastException for any elements e1 and e2 in the range). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). This algorithm offers guaranteed n*method_1 performance, and can approach linear performance on nearly sorted lists.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "mergeSortInPlace(int[] a, int fromIndex, int toIndex)",
    "name": "mergeSortInPlace",
    "containingClass": {
      "qualifiedName": "cern.colt.Sorting",
      "name": "Sorting",
      "isArray": false
    },
    "targetClass": "cern.colt.Sorting",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[I",
          "name": "int[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      }
    ],
    "protocol": {
      "member": "mergeSortInPlace(int[] a, int fromIndex, int toIndex)",
      "comment": "Sorts the specified range of the specified array of elements. This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). This algorithm offers guaranteed n*method_0 performance, and can approach linear performance on nearly sorted lists.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "quickSort(byte[] a, int fromIndex, int toIndex, cern.colt.function.ByteComparator c)",
    "name": "quickSort",
    "containingClass": {
      "qualifiedName": "cern.colt.Sorting",
      "name": "Sorting",
      "isArray": false
    },
    "targetClass": "cern.colt.Sorting",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[B",
          "name": "byte[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "cern.colt.function.ByteComparator",
          "name": "ByteComparator",
          "isArray": false
        },
        "name": "c"
      }
    ],
    "protocol": {
      "member": "quickSort(byte[] a, int fromIndex, int toIndex, cern.colt.function.ByteComparator c)",
      "comment": "Sorts the specified range of the specified array of elements according to the order induced by the specified comparator. All elements in the range must be mutually comparable by the specified comparator (that is, method_0 must not throw a ClassCastException for any elements e1 and e2 in the range). The sorting algorithm is a tuned quicksort, adapted from Jon L. Bentley and M. Douglas McIlroy's \"Engineering a Sort Function\", Software-Practice and Experience, Vol. method_1 P. 1249-1265 (November 1993). This algorithm offers n*method_2 performance on many data sets that cause other quicksorts to degrade to quadratic performance.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "quickSort(char[] a, int fromIndex, int toIndex, cern.colt.function.CharComparator c)",
    "name": "quickSort",
    "containingClass": {
      "qualifiedName": "cern.colt.Sorting",
      "name": "Sorting",
      "isArray": false
    },
    "targetClass": "cern.colt.Sorting",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[C",
          "name": "char[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "cern.colt.function.CharComparator",
          "name": "CharComparator",
          "isArray": false
        },
        "name": "c"
      }
    ],
    "protocol": {
      "member": "quickSort(char[] a, int fromIndex, int toIndex, cern.colt.function.CharComparator c)",
      "comment": "Sorts the specified range of the specified array of elements according to the order induced by the specified comparator. All elements in the range must be mutually comparable by the specified comparator (that is, method_0 must not throw a ClassCastException for any elements e1 and e2 in the range). The sorting algorithm is a tuned quicksort, adapted from Jon L. Bentley and M. Douglas McIlroy's \"Engineering a Sort Function\", Software-Practice and Experience, Vol. method_1 P. 1249-1265 (November 1993). This algorithm offers n*method_2 performance on many data sets that cause other quicksorts to degrade to quadratic performance.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "quickSort(double[] a, int fromIndex, int toIndex, cern.colt.function.DoubleComparator c)",
    "name": "quickSort",
    "containingClass": {
      "qualifiedName": "cern.colt.Sorting",
      "name": "Sorting",
      "isArray": false
    },
    "targetClass": "cern.colt.Sorting",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "cern.colt.function.DoubleComparator",
          "name": "DoubleComparator",
          "isArray": false
        },
        "name": "c"
      }
    ],
    "protocol": {
      "member": "quickSort(double[] a, int fromIndex, int toIndex, cern.colt.function.DoubleComparator c)",
      "comment": "Sorts the specified range of the specified array of elements according to the order induced by the specified comparator. All elements in the range must be mutually comparable by the specified comparator (that is, method_0 must not throw a ClassCastException for any elements e1 and e2 in the range). The sorting algorithm is a tuned quicksort, adapted from Jon L. Bentley and M. Douglas McIlroy's \"Engineering a Sort Function\", Software-Practice and Experience, Vol. method_1 P. 1249-1265 (November 1993). This algorithm offers n*method_2 performance on many data sets that cause other quicksorts to degrade to quadratic performance.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "quickSort(float[] a, int fromIndex, int toIndex, cern.colt.function.FloatComparator c)",
    "name": "quickSort",
    "containingClass": {
      "qualifiedName": "cern.colt.Sorting",
      "name": "Sorting",
      "isArray": false
    },
    "targetClass": "cern.colt.Sorting",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[F",
          "name": "float[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "cern.colt.function.FloatComparator",
          "name": "FloatComparator",
          "isArray": false
        },
        "name": "c"
      }
    ],
    "protocol": {
      "member": "quickSort(float[] a, int fromIndex, int toIndex, cern.colt.function.FloatComparator c)",
      "comment": "Sorts the specified range of the specified array of elements according to the order induced by the specified comparator. All elements in the range must be mutually comparable by the specified comparator (that is, method_0 must not throw a ClassCastException for any elements e1 and e2 in the range). The sorting algorithm is a tuned quicksort, adapted from Jon L. Bentley and M. Douglas McIlroy's \"Engineering a Sort Function\", Software-Practice and Experience, Vol. method_1 P. 1249-1265 (November 1993). This algorithm offers n*method_2 performance on many data sets that cause other quicksorts to degrade to quadratic performance.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "quickSort(int[] a, int fromIndex, int toIndex, cern.colt.function.IntComparator c)",
    "name": "quickSort",
    "containingClass": {
      "qualifiedName": "cern.colt.Sorting",
      "name": "Sorting",
      "isArray": false
    },
    "targetClass": "cern.colt.Sorting",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[I",
          "name": "int[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "cern.colt.function.IntComparator",
          "name": "IntComparator",
          "isArray": false
        },
        "name": "c"
      }
    ],
    "protocol": {
      "member": "quickSort(int[] a, int fromIndex, int toIndex, cern.colt.function.IntComparator c)",
      "comment": "Sorts the specified range of the specified array of elements according to the order induced by the specified comparator. All elements in the range must be mutually comparable by the specified comparator (that is, method_0 must not throw a ClassCastException for any elements e1 and e2 in the range). The sorting algorithm is a tuned quicksort, adapted from Jon L. Bentley and M. Douglas McIlroy's \"Engineering a Sort Function\", Software-Practice and Experience, Vol. method_1 P. 1249-1265 (November 1993). This algorithm offers n*method_2 performance on many data sets that cause other quicksorts to degrade to quadratic performance.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "quickSort(long[] a, int fromIndex, int toIndex, cern.colt.function.LongComparator c)",
    "name": "quickSort",
    "containingClass": {
      "qualifiedName": "cern.colt.Sorting",
      "name": "Sorting",
      "isArray": false
    },
    "targetClass": "cern.colt.Sorting",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[J",
          "name": "long[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "cern.colt.function.LongComparator",
          "name": "LongComparator",
          "isArray": false
        },
        "name": "c"
      }
    ],
    "protocol": {
      "member": "quickSort(long[] a, int fromIndex, int toIndex, cern.colt.function.LongComparator c)",
      "comment": "Sorts the specified range of the specified array of elements according to the order induced by the specified comparator. All elements in the range must be mutually comparable by the specified comparator (that is, method_0 must not throw a ClassCastException for any elements e1 and e2 in the range). The sorting algorithm is a tuned quicksort, adapted from Jon L. Bentley and M. Douglas McIlroy's \"Engineering a Sort Function\", Software-Practice and Experience, Vol. method_1 P. 1249-1265 (November 1993). This algorithm offers n*method_2 performance on many data sets that cause other quicksorts to degrade to quadratic performance.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "quickSort(java.lang.Object[] a)",
    "name": "quickSort",
    "containingClass": {
      "qualifiedName": "cern.colt.Sorting",
      "name": "Sorting",
      "isArray": false
    },
    "targetClass": "cern.colt.Sorting",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "quickSort(java.lang.Object[] a)",
      "comment": "Sorts the specified range of the receiver into ascending order, according to the natural ordering of its elements. All elements in this range must implement the Comparable interface. Furthermore, all elements in this range must be mutually comparable (that is, method_0 must not throw a ClassCastException for any elements e1 and e2 in the array). The sorting algorithm is a tuned quicksort, adapted from Jon L. Bentley and M. Douglas McIlroy's \"Engineering a Sort Function\", Software-Practice and Experience, Vol. method_1 P. 1249-1265 (November 1993). This algorithm offers n*method_2 performance on many data sets that cause other quicksorts to degrade to quadratic performance.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "quickSort(java.lang.Object[] a, int fromIndex, int toIndex)",
    "name": "quickSort",
    "containingClass": {
      "qualifiedName": "cern.colt.Sorting",
      "name": "Sorting",
      "isArray": false
    },
    "targetClass": "cern.colt.Sorting",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      }
    ],
    "protocol": {
      "member": "quickSort(java.lang.Object[] a, int fromIndex, int toIndex)",
      "comment": "Sorts the specified range of the receiver into ascending order, according to the natural ordering of its elements. All elements in this range must implement the Comparable interface. Furthermore, all elements in this range must be mutually comparable (that is, method_0 must not throw a ClassCastException for any elements e1 and e2 in the array).",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "quickSort(java.lang.Object[] a, int fromIndex, int toIndex, java.util.Comparator c)",
    "name": "quickSort",
    "containingClass": {
      "qualifiedName": "cern.colt.Sorting",
      "name": "Sorting",
      "isArray": false
    },
    "targetClass": "cern.colt.Sorting",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "java.util.Comparator",
          "name": "Comparator",
          "isArray": false
        },
        "name": "c"
      }
    ],
    "protocol": {
      "member": "quickSort(java.lang.Object[] a, int fromIndex, int toIndex, java.util.Comparator c)",
      "comment": "Sorts the specified range of the specified array according to the order induced by the specified comparator. All elements in the range must be mutually comparable by the specified comparator (that is, method_0 must not throw a ClassCastException for any elements e1 and e2 in the range). The sorting algorithm is a tuned quicksort, adapted from Jon L. Bentley and M. Douglas McIlroy's \"Engineering a Sort Function\", Software-Practice and Experience, Vol. method_1 P. 1249-1265 (November 1993). This algorithm offers n*method_2 performance on many data sets that cause other quicksorts to degrade to quadratic performance.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "quickSort(java.lang.Object[] a, java.util.Comparator c)",
    "name": "quickSort",
    "containingClass": {
      "qualifiedName": "cern.colt.Sorting",
      "name": "Sorting",
      "isArray": false
    },
    "targetClass": "cern.colt.Sorting",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "java.util.Comparator",
          "name": "Comparator",
          "isArray": false
        },
        "name": "c"
      }
    ],
    "protocol": {
      "member": "quickSort(java.lang.Object[] a, java.util.Comparator c)",
      "comment": "Sorts the specified array according to the order induced by the specified comparator. All elements in the range must be mutually comparable by the specified comparator (that is, method_0 must not throw a ClassCastException for any elements e1 and e2 in the range). The sorting algorithm is a tuned quicksort, adapted from Jon L. Bentley and M. Douglas McIlroy's \"Engineering a Sort Function\", Software-Practice and Experience, Vol. method_1 P. 1249-1265 (November 1993). This algorithm offers n*method_2 performance on many data sets that cause other quicksorts to degrade to quadratic performance.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "quickSort(short[] a, int fromIndex, int toIndex, cern.colt.function.ShortComparator c)",
    "name": "quickSort",
    "containingClass": {
      "qualifiedName": "cern.colt.Sorting",
      "name": "Sorting",
      "isArray": false
    },
    "targetClass": "cern.colt.Sorting",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[S",
          "name": "short[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "cern.colt.function.ShortComparator",
          "name": "ShortComparator",
          "isArray": false
        },
        "name": "c"
      }
    ],
    "protocol": {
      "member": "quickSort(short[] a, int fromIndex, int toIndex, cern.colt.function.ShortComparator c)",
      "comment": "Sorts the specified range of the specified array of elements according to the order induced by the specified comparator. All elements in the range must be mutually comparable by the specified comparator (that is, method_0 must not throw a ClassCastException for any elements e1 and e2 in the range). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). This algorithm offers guaranteed n*method_1 performance, and can approach linear performance on nearly sorted lists.",
      "kind": "FreeText",
      "condition": ""
    }
  }
]