[
  {
    "signature": "sort(int[] a)",
    "name": "sort",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[I",
          "name": "int[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "sort(int[] a)",
      "comment": "Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers method_0 performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "sort(int[] a, int fromIndex, int toIndex)",
    "name": "sort",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[I",
          "name": "int[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      }
    ],
    "protocol": {
      "member": "sort(int[] a, int fromIndex, int toIndex)",
      "comment": "Sorts the specified range of the array into ascending order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers method_0 performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "sort(long[] a)",
    "name": "sort",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[J",
          "name": "long[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "sort(long[] a)",
      "comment": "Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers method_0 performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "sort(long[] a, int fromIndex, int toIndex)",
    "name": "sort",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[J",
          "name": "long[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      }
    ],
    "protocol": {
      "member": "sort(long[] a, int fromIndex, int toIndex)",
      "comment": "Sorts the specified range of the array into ascending order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers method_0 performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "sort(short[] a)",
    "name": "sort",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[S",
          "name": "short[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "sort(short[] a)",
      "comment": "Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers method_0 performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "sort(short[] a, int fromIndex, int toIndex)",
    "name": "sort",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[S",
          "name": "short[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      }
    ],
    "protocol": {
      "member": "sort(short[] a, int fromIndex, int toIndex)",
      "comment": "Sorts the specified range of the array into ascending order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers method_0 performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "sort(char[] a)",
    "name": "sort",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[C",
          "name": "char[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "sort(char[] a)",
      "comment": "Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers method_0 performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "sort(char[] a, int fromIndex, int toIndex)",
    "name": "sort",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[C",
          "name": "char[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      }
    ],
    "protocol": {
      "member": "sort(char[] a, int fromIndex, int toIndex)",
      "comment": "Sorts the specified range of the array into ascending order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers method_0 performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "sort(byte[] a)",
    "name": "sort",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[B",
          "name": "byte[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "sort(byte[] a)",
      "comment": "Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers method_0 performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "sort(byte[] a, int fromIndex, int toIndex)",
    "name": "sort",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[B",
          "name": "byte[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      }
    ],
    "protocol": {
      "member": "sort(byte[] a, int fromIndex, int toIndex)",
      "comment": "Sorts the specified range of the array into ascending order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers method_0 performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "sort(float[] a)",
    "name": "sort",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[F",
          "name": "float[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "sort(float[] a)",
      "comment": "Sorts the specified array into ascending numerical order. The < relation does not provide a total order on all float values: -0method_1 == 0method_1 is true and a method_3 value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method method_4: -0method_1 is treated as less than value 0method_1 and method_3 is considered greater than any other value and all method_3 values are considered equal. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers method_0 performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "sort(float[] a, int fromIndex, int toIndex)",
    "name": "sort",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[F",
          "name": "float[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      }
    ],
    "protocol": {
      "member": "sort(float[] a, int fromIndex, int toIndex)",
      "comment": "Sorts the specified range of the array into ascending order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. The < relation does not provide a total order on all float values: -0method_1 == 0method_1 is true and a method_3 value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method method_4: -0method_1 is treated as less than value 0method_1 and method_3 is considered greater than any other value and all method_3 values are considered equal. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers method_0 performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "sort(double[] a)",
    "name": "sort",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "sort(double[] a)",
      "comment": "Sorts the specified array into ascending numerical order. The < relation does not provide a total order on all double values: -0method_1 == 0method_1 is true and a method_3 value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method method_4: -0method_1 is treated as less than value 0method_1 and method_3 is considered greater than any other value and all method_3 values are considered equal. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers method_0 performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "sort(double[] a, int fromIndex, int toIndex)",
    "name": "sort",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      }
    ],
    "protocol": {
      "member": "sort(double[] a, int fromIndex, int toIndex)",
      "comment": "Sorts the specified range of the array into ascending order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. The < relation does not provide a total order on all double values: -0method_1 == 0method_1 is true and a method_3 value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method method_4: -0method_1 is treated as less than value 0method_1 and method_3 is considered greater than any other value and all method_3 values are considered equal. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers method_0 performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "parallelSort(byte[] a)",
    "name": "parallelSort",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[B",
          "name": "byte[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "parallelSort(byte[] a)",
      "comment": "Sorts the specified array into ascending numerical order. @implNote The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method_0 method_4 method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method_0 method_4 method. The algorithm requires a working space no greater than the size of the original array. The method_2 ForkJoin common pool is used to execute any parallel tasks.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "parallelSort(byte[] a, int fromIndex, int toIndex)",
    "name": "parallelSort",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[B",
          "name": "byte[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      }
    ],
    "protocol": {
      "member": "parallelSort(byte[] a, int fromIndex, int toIndex)",
      "comment": "Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. @implNote The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method_0 method_4 method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method_0 method_4 method. The algorithm requires a working space no greater than the size of the specified range of the original array. The method_2 ForkJoin common pool is used to execute any parallel tasks.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "parallelSort(char[] a)",
    "name": "parallelSort",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[C",
          "name": "char[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "parallelSort(char[] a)",
      "comment": "Sorts the specified array into ascending numerical order. @implNote The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method_0 method_4 method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method_0 method_4 method. The algorithm requires a working space no greater than the size of the original array. The method_2 ForkJoin common pool is used to execute any parallel tasks.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "parallelSort(char[] a, int fromIndex, int toIndex)",
    "name": "parallelSort",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[C",
          "name": "char[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      }
    ],
    "protocol": {
      "member": "parallelSort(char[] a, int fromIndex, int toIndex)",
      "comment": "Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method_0 method_4 method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method_0 method_4 method. The algorithm requires a working space no greater than the size of the specified range of the original array. The method_2 ForkJoin common pool is used to execute any parallel tasks.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "parallelSort(short[] a)",
    "name": "parallelSort",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[S",
          "name": "short[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "parallelSort(short[] a)",
      "comment": "Sorts the specified array into ascending numerical order. @implNote The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method_0 method_4 method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method_0 method_4 method. The algorithm requires a working space no greater than the size of the original array. The method_2 ForkJoin common pool is used to execute any parallel tasks.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "parallelSort(short[] a, int fromIndex, int toIndex)",
    "name": "parallelSort",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[S",
          "name": "short[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      }
    ],
    "protocol": {
      "member": "parallelSort(short[] a, int fromIndex, int toIndex)",
      "comment": "Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. @implNote The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method_0 method_4 method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method_0 method_4 method. The algorithm requires a working space no greater than the size of the specified range of the original array. The method_2 ForkJoin common pool is used to execute any parallel tasks.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "parallelSort(int[] a)",
    "name": "parallelSort",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[I",
          "name": "int[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "parallelSort(int[] a)",
      "comment": "Sorts the specified array into ascending numerical order. @implNote The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method_0 method_4 method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method_0 method_4 method. The algorithm requires a working space no greater than the size of the original array. The method_2 ForkJoin common pool is used to execute any parallel tasks.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "parallelSort(int[] a, int fromIndex, int toIndex)",
    "name": "parallelSort",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[I",
          "name": "int[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      }
    ],
    "protocol": {
      "member": "parallelSort(int[] a, int fromIndex, int toIndex)",
      "comment": "Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. @implNote The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method_0 method_4 method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method_0 method_4 method. The algorithm requires a working space no greater than the size of the specified range of the original array. The method_2 ForkJoin common pool is used to execute any parallel tasks.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "parallelSort(long[] a)",
    "name": "parallelSort",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[J",
          "name": "long[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "parallelSort(long[] a)",
      "comment": "Sorts the specified array into ascending numerical order. @implNote The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method_0 method_4 method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method_0 method_4 method. The algorithm requires a working space no greater than the size of the original array. The method_2 ForkJoin common pool is used to execute any parallel tasks.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "parallelSort(long[] a, int fromIndex, int toIndex)",
    "name": "parallelSort",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[J",
          "name": "long[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      }
    ],
    "protocol": {
      "member": "parallelSort(long[] a, int fromIndex, int toIndex)",
      "comment": "Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. @implNote The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method_0 method_4 method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method_0 method_4 method. The algorithm requires a working space no greater than the size of the specified range of the original array. The method_2 ForkJoin common pool is used to execute any parallel tasks.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "parallelSort(float[] a)",
    "name": "parallelSort",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[F",
          "name": "float[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "parallelSort(float[] a)",
      "comment": "Sorts the specified array into ascending numerical order. The < relation does not provide a total order on all float values: -0method_3 == 0method_3 is true and a method_5 value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method method_6: -0method_3 is treated as less than value 0method_3 and method_5 is considered greater than any other value and all method_5 values are considered equal. @implNote The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method_0 method_12 method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method_0 method_12 method. The algorithm requires a working space no greater than the size of the original array. The method_2 ForkJoin common pool is used to execute any parallel tasks.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "parallelSort(float[] a, int fromIndex, int toIndex)",
    "name": "parallelSort",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[F",
          "name": "float[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      }
    ],
    "protocol": {
      "member": "parallelSort(float[] a, int fromIndex, int toIndex)",
      "comment": "Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. The < relation does not provide a total order on all float values: -0method_3 == 0method_3 is true and a method_5 value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method method_6: -0method_3 is treated as less than value 0method_3 and method_5 is considered greater than any other value and all method_5 values are considered equal. @implNote The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method_0 method_12 method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method_0 method_12 method. The algorithm requires a working space no greater than the size of the specified range of the original array. The method_2 ForkJoin common pool is used to execute any parallel tasks.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "parallelSort(double[] a)",
    "name": "parallelSort",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "parallelSort(double[] a)",
      "comment": "Sorts the specified array into ascending numerical order. The < relation does not provide a total order on all double values: -0method_3 == 0method_3 is true and a method_5 value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method method_6: -0method_3 is treated as less than value 0method_3 and method_5 is considered greater than any other value and all method_5 values are considered equal. @implNote The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method_0 method_12 method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method_0 method_12 method. The algorithm requires a working space no greater than the size of the original array. The method_2 ForkJoin common pool is used to execute any parallel tasks.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "parallelSort(double[] a, int fromIndex, int toIndex)",
    "name": "parallelSort",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      }
    ],
    "protocol": {
      "member": "parallelSort(double[] a, int fromIndex, int toIndex)",
      "comment": "Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. The < relation does not provide a total order on all double values: -0method_3 == 0method_3 is true and a method_5 value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method method_6: -0method_3 is treated as less than value 0method_3 and method_5 is considered greater than any other value and all method_5 values are considered equal. @implNote The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method_0 method_12 method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method_0 method_12 method. The algorithm requires a working space no greater than the size of the specified range of the original array. The method_2 ForkJoin common pool is used to execute any parallel tasks.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "parallelSort(T[] a)",
    "name": "parallelSort",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Comparable;",
          "name": "Comparable[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "parallelSort(T[] a)",
      "comment": "Sorts the specified array of objects into ascending order, according to the Comparable natural ordering of its elements. All elements in the array must implement the Comparable interface. Furthermore, all elements in the array must be mutually comparable (that is, method_0 must not throw a ClassCastException for any elements e1 and e2 in the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. @implNote The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method_1 method_6 method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method_1 method_6 method. The algorithm requires a working space no greater than the size of the original array. The method_3 ForkJoin common pool is used to execute any parallel tasks.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "parallelSort(T[] a, int fromIndex, int toIndex)",
    "name": "parallelSort",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Comparable;",
          "name": "Comparable[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      }
    ],
    "protocol": {
      "member": "parallelSort(T[] a, int fromIndex, int toIndex)",
      "comment": "Sorts the specified range of the specified array of objects into ascending order, according to the Comparable natural ordering of its elements. The range to be sorted extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be sorted is empty.) All elements in this range must implement the Comparable interface. Furthermore, all elements in this range must be mutually comparable (that is, method_0 must not throw a ClassCastException for any elements e1 and e2 in the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. @implNote The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method_1 method_6 method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method_1 method_6 method. The algorithm requires a working space no greater than the size of the specified range of the original array. The method_3 ForkJoin common pool is used to execute any parallel tasks.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "parallelSort(T[] a, java.util.Comparator<? super T> cmp)",
    "name": "parallelSort",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "java.util.Comparator",
          "name": "Comparator",
          "isArray": false
        },
        "name": "cmp"
      }
    ],
    "protocol": {
      "member": "parallelSort(T[] a, java.util.Comparator<? super T> cmp)",
      "comment": "Sorts the specified array of objects according to the order induced by the specified comparator. All elements in the array must be mutually comparable by the specified comparator (that is, method_0 must not throw a ClassCastException for any elements e1 and e2 in the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. @implNote The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method_1 method_6 method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method_1 method_6 method. The algorithm requires a working space no greater than the size of the original array. The method_3 ForkJoin common pool is used to execute any parallel tasks.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "parallelSort(T[] a, int fromIndex, int toIndex, java.util.Comparator<? super T> cmp)",
    "name": "parallelSort",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "java.util.Comparator",
          "name": "Comparator",
          "isArray": false
        },
        "name": "cmp"
      }
    ],
    "protocol": {
      "member": "parallelSort(T[] a, int fromIndex, int toIndex, java.util.Comparator<? super T> cmp)",
      "comment": "Sorts the specified range of the specified array of objects according to the order induced by the specified comparator. The range to be sorted extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be sorted is empty.) All elements in the range must be mutually comparable by the specified comparator (that is, method_0 must not throw a ClassCastException for any elements e1 and e2 in the range). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. @implNote The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method_1 method_6 method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method_1 method_6 method. The algorithm requires a working space no greater than the size of the specified range of the original array. The method_3 ForkJoin common pool is used to execute any parallel tasks.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "sort(java.lang.Object[] a)",
    "name": "sort",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "sort(java.lang.Object[] a)",
      "comment": "Sorts the specified array of objects into ascending order, according to the Comparable natural ordering of its elements. All elements in the array must implement the Comparable interface. Furthermore, all elements in the array must be mutually comparable (that is, method_0 must not throw a ClassCastException for any elements e1 and e2 in the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n method_1 comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters's list sort for Python ( TimSort). It uses techniques from Peter McIlroy's \"Optimistic Sorting and Information Theoretic Complexity\", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "sort(java.lang.Object[] a, int fromIndex, int toIndex)",
    "name": "sort",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      }
    ],
    "protocol": {
      "member": "sort(java.lang.Object[] a, int fromIndex, int toIndex)",
      "comment": "Sorts the specified range of the specified array of objects into ascending order, according to the Comparable natural ordering of its elements. The range to be sorted extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be sorted is empty.) All elements in this range must implement the Comparable interface. Furthermore, all elements in this range must be mutually comparable (that is, method_0 must not throw a ClassCastException for any elements e1 and e2 in the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n method_1 comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters's list sort for Python ( TimSort). It uses techniques from Peter McIlroy's \"Optimistic Sorting and Information Theoretic Complexity\", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "sort(T[] a, java.util.Comparator<? super T> c)",
    "name": "sort",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "java.util.Comparator",
          "name": "Comparator",
          "isArray": false
        },
        "name": "c"
      }
    ],
    "protocol": {
      "member": "sort(T[] a, java.util.Comparator<? super T> c)",
      "comment": "Sorts the specified array of objects according to the order induced by the specified comparator. All elements in the array must be mutually comparable by the specified comparator (that is, method_0 must not throw a ClassCastException for any elements e1 and e2 in the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n method_1 comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters's list sort for Python ( TimSort). It uses techniques from Peter McIlroy's \"Optimistic Sorting and Information Theoretic Complexity\", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "sort(T[] a, int fromIndex, int toIndex, java.util.Comparator<? super T> c)",
    "name": "sort",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "java.util.Comparator",
          "name": "Comparator",
          "isArray": false
        },
        "name": "c"
      }
    ],
    "protocol": {
      "member": "sort(T[] a, int fromIndex, int toIndex, java.util.Comparator<? super T> c)",
      "comment": "Sorts the specified range of the specified array of objects according to the order induced by the specified comparator. The range to be sorted extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be sorted is empty.) All elements in the range must be mutually comparable by the specified comparator (that is, method_0 must not throw a ClassCastException for any elements e1 and e2 in the range). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n method_1 comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters's list sort for Python ( TimSort). It uses techniques from Peter McIlroy's \"Optimistic Sorting and Information Theoretic Complexity\", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "parallelPrefix(T[] array, java.util.function.BinaryOperator<T> op)",
    "name": "parallelPrefix",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "array"
      },
      {
        "type": {
          "qualifiedName": "java.util.function.BinaryOperator",
          "name": "BinaryOperator",
          "isArray": false
        },
        "name": "op"
      }
    ],
    "protocol": {
      "member": "parallelPrefix(T[] array, java.util.function.BinaryOperator<T> op)",
      "comment": "Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holds [2, 1, 0, 3] and the operation performs addition, then upon return the array holds [2, 3, 3, 6]. Parallel prefix computation is usually more efficient than sequential loops for large arrays.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "parallelPrefix(T[] array, int fromIndex, int toIndex, java.util.function.BinaryOperator<T> op)",
    "name": "parallelPrefix",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "array"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "java.util.function.BinaryOperator",
          "name": "BinaryOperator",
          "isArray": false
        },
        "name": "op"
      }
    ],
    "protocol": {
      "member": "parallelPrefix(T[] array, int fromIndex, int toIndex, java.util.function.BinaryOperator<T> op)",
      "comment": "Performs method_0 for the given subrange of the array.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "parallelPrefix(long[] array, java.util.function.LongBinaryOperator op)",
    "name": "parallelPrefix",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[J",
          "name": "long[]",
          "isArray": true
        },
        "name": "array"
      },
      {
        "type": {
          "qualifiedName": "java.util.function.LongBinaryOperator",
          "name": "LongBinaryOperator",
          "isArray": false
        },
        "name": "op"
      }
    ],
    "protocol": {
      "member": "parallelPrefix(long[] array, java.util.function.LongBinaryOperator op)",
      "comment": "Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holds [2, 1, 0, 3] and the operation performs addition, then upon return the array holds [2, 3, 3, 6]. Parallel prefix computation is usually more efficient than sequential loops for large arrays.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "parallelPrefix(long[] array, int fromIndex, int toIndex, java.util.function.LongBinaryOperator op)",
    "name": "parallelPrefix",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[J",
          "name": "long[]",
          "isArray": true
        },
        "name": "array"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "java.util.function.LongBinaryOperator",
          "name": "LongBinaryOperator",
          "isArray": false
        },
        "name": "op"
      }
    ],
    "protocol": {
      "member": "parallelPrefix(long[] array, int fromIndex, int toIndex, java.util.function.LongBinaryOperator op)",
      "comment": "Performs method_0 for the given subrange of the array.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "parallelPrefix(double[] array, java.util.function.DoubleBinaryOperator op)",
    "name": "parallelPrefix",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "array"
      },
      {
        "type": {
          "qualifiedName": "java.util.function.DoubleBinaryOperator",
          "name": "DoubleBinaryOperator",
          "isArray": false
        },
        "name": "op"
      }
    ],
    "protocol": {
      "member": "parallelPrefix(double[] array, java.util.function.DoubleBinaryOperator op)",
      "comment": "Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holds [2method_0, 1method_0, 0method_0, 3method_0] and the operation performs addition, then upon return the array holds [2method_0, 3method_0, 3method_0, 6method_0]. Parallel prefix computation is usually more efficient than sequential loops for large arrays.  Because floating-point operations may not be strictly associative, the returned result may not be identical to the value that would be obtained if the operation was performed sequentially.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "parallelPrefix(double[] array, int fromIndex, int toIndex, java.util.function.DoubleBinaryOperator op)",
    "name": "parallelPrefix",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "array"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "java.util.function.DoubleBinaryOperator",
          "name": "DoubleBinaryOperator",
          "isArray": false
        },
        "name": "op"
      }
    ],
    "protocol": {
      "member": "parallelPrefix(double[] array, int fromIndex, int toIndex, java.util.function.DoubleBinaryOperator op)",
      "comment": "Performs method_0 for the given subrange of the array.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "parallelPrefix(int[] array, java.util.function.IntBinaryOperator op)",
    "name": "parallelPrefix",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[I",
          "name": "int[]",
          "isArray": true
        },
        "name": "array"
      },
      {
        "type": {
          "qualifiedName": "java.util.function.IntBinaryOperator",
          "name": "IntBinaryOperator",
          "isArray": false
        },
        "name": "op"
      }
    ],
    "protocol": {
      "member": "parallelPrefix(int[] array, java.util.function.IntBinaryOperator op)",
      "comment": "Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holds [2, 1, 0, 3] and the operation performs addition, then upon return the array holds [2, 3, 3, 6]. Parallel prefix computation is usually more efficient than sequential loops for large arrays.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "parallelPrefix(int[] array, int fromIndex, int toIndex, java.util.function.IntBinaryOperator op)",
    "name": "parallelPrefix",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[I",
          "name": "int[]",
          "isArray": true
        },
        "name": "array"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "java.util.function.IntBinaryOperator",
          "name": "IntBinaryOperator",
          "isArray": false
        },
        "name": "op"
      }
    ],
    "protocol": {
      "member": "parallelPrefix(int[] array, int fromIndex, int toIndex, java.util.function.IntBinaryOperator op)",
      "comment": "Performs method_0 for the given subrange of the array.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "binarySearch(long[] a, long key)",
    "name": "binarySearch",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[J",
          "name": "long[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "long",
          "name": "long",
          "isArray": false
        },
        "name": "key"
      }
    ],
    "protocol": {
      "member": "binarySearch(long[] a, long key)",
      "comment": "Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the method_0 method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.",
      "kind": "FreeText",
      "condition": "java.util.Arrays.sort(args[0])->java.util.Arrays.binarySearch(args[0],args[1])"
    }
  },
  {
    "signature": "binarySearch(long[] a, int fromIndex, int toIndex, long key)",
    "name": "binarySearch",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[J",
          "name": "long[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "long",
          "name": "long",
          "isArray": false
        },
        "name": "key"
      }
    ],
    "protocol": {
      "member": "binarySearch(long[] a, int fromIndex, int toIndex, long key)",
      "comment": "Searches a range of the specified array of longs for the specified value using the binary search algorithm. The range must be sorted (as by the method_0 method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "binarySearch(int[] a, int key)",
    "name": "binarySearch",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[I",
          "name": "int[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "key"
      }
    ],
    "protocol": {
      "member": "binarySearch(int[] a, int key)",
      "comment": "Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the method_0 method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.",
      "kind": "FreeText",
      "condition": "java.util.Arrays.sort(args[0])->java.util.Arrays.binarySearch(args[0],args[1])"
    }
  },
  {
    "signature": "binarySearch(int[] a, int fromIndex, int toIndex, int key)",
    "name": "binarySearch",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[I",
          "name": "int[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "key"
      }
    ],
    "protocol": {
      "member": "binarySearch(int[] a, int fromIndex, int toIndex, int key)",
      "comment": "Searches a range of the specified array of ints for the specified value using the binary search algorithm. The range must be sorted (as by the method_0 method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "binarySearch(short[] a, short key)",
    "name": "binarySearch",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[S",
          "name": "short[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "short",
          "name": "short",
          "isArray": false
        },
        "name": "key"
      }
    ],
    "protocol": {
      "member": "binarySearch(short[] a, short key)",
      "comment": "Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the method_0 method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.",
      "kind": "FreeText",
      "condition": "java.util.Arrays.sort(args[0])->java.util.Arrays.binarySearch(args[0],args[1])"
    }
  },
  {
    "signature": "binarySearch(short[] a, int fromIndex, int toIndex, short key)",
    "name": "binarySearch",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[S",
          "name": "short[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "short",
          "name": "short",
          "isArray": false
        },
        "name": "key"
      }
    ],
    "protocol": {
      "member": "binarySearch(short[] a, int fromIndex, int toIndex, short key)",
      "comment": "Searches a range of the specified array of shorts for the specified value using the binary search algorithm. The range must be sorted (as by the method_0 method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "binarySearch(char[] a, char key)",
    "name": "binarySearch",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[C",
          "name": "char[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "char",
          "name": "char",
          "isArray": false
        },
        "name": "key"
      }
    ],
    "protocol": {
      "member": "binarySearch(char[] a, char key)",
      "comment": "Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the method_0 method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.",
      "kind": "FreeText",
      "condition": "java.util.Arrays.sort(args[0])->java.util.Arrays.binarySearch(args[0],args[1])"
    }
  },
  {
    "signature": "binarySearch(char[] a, int fromIndex, int toIndex, char key)",
    "name": "binarySearch",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[C",
          "name": "char[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "char",
          "name": "char",
          "isArray": false
        },
        "name": "key"
      }
    ],
    "protocol": {
      "member": "binarySearch(char[] a, int fromIndex, int toIndex, char key)",
      "comment": "Searches a range of the specified array of chars for the specified value using the binary search algorithm. The range must be sorted (as by the method_0 method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "binarySearch(byte[] a, byte key)",
    "name": "binarySearch",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[B",
          "name": "byte[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "byte",
          "name": "byte",
          "isArray": false
        },
        "name": "key"
      }
    ],
    "protocol": {
      "member": "binarySearch(byte[] a, byte key)",
      "comment": "Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the method_0 method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.",
      "kind": "FreeText",
      "condition": "java.util.Arrays.sort(args[0])->java.util.Arrays.binarySearch(args[0],args[1])"
    }
  },
  {
    "signature": "binarySearch(byte[] a, int fromIndex, int toIndex, byte key)",
    "name": "binarySearch",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[B",
          "name": "byte[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "byte",
          "name": "byte",
          "isArray": false
        },
        "name": "key"
      }
    ],
    "protocol": {
      "member": "binarySearch(byte[] a, int fromIndex, int toIndex, byte key)",
      "comment": "Searches a range of the specified array of bytes for the specified value using the binary search algorithm. The range must be sorted (as by the method_0 method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "binarySearch(double[] a, double key)",
    "name": "binarySearch",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "key"
      }
    ],
    "protocol": {
      "member": "binarySearch(double[] a, double key)",
      "comment": "Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the method_0 method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.",
      "kind": "FreeText",
      "condition": "java.util.Arrays.sort(args[0])->java.util.Arrays.binarySearch(args[0],args[1])"
    }
  },
  {
    "signature": "binarySearch(double[] a, int fromIndex, int toIndex, double key)",
    "name": "binarySearch",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "key"
      }
    ],
    "protocol": {
      "member": "binarySearch(double[] a, int fromIndex, int toIndex, double key)",
      "comment": "Searches a range of the specified array of doubles for the specified value using the binary search algorithm. The range must be sorted (as by the method_0 method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "binarySearch(float[] a, float key)",
    "name": "binarySearch",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[F",
          "name": "float[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "float",
          "name": "float",
          "isArray": false
        },
        "name": "key"
      }
    ],
    "protocol": {
      "member": "binarySearch(float[] a, float key)",
      "comment": "Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the method_0 method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.",
      "kind": "FreeText",
      "condition": "java.util.Arrays.sort(args[0])->java.util.Arrays.binarySearch(args[0],args[1])"
    }
  },
  {
    "signature": "binarySearch(float[] a, int fromIndex, int toIndex, float key)",
    "name": "binarySearch",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[F",
          "name": "float[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "float",
          "name": "float",
          "isArray": false
        },
        "name": "key"
      }
    ],
    "protocol": {
      "member": "binarySearch(float[] a, int fromIndex, int toIndex, float key)",
      "comment": "Searches a range of the specified array of floats for the specified value using the binary search algorithm. The range must be sorted (as by the method_0 method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "binarySearch(java.lang.Object[] a, java.lang.Object key)",
    "name": "binarySearch",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "key"
      }
    ],
    "protocol": {
      "member": "binarySearch(java.lang.Object[] a, java.lang.Object key)",
      "comment": "Searches the specified array for the specified object using the binary search algorithm. The array must be sorted into ascending order according to the Comparable natural ordering of its elements (as by the method_0 method) prior to making this call. If it is not sorted, the results are undefined. (If the array contains elements that are not mutually comparable (for example, strings and integers), it cannot be sorted according to the natural ordering of its elements, hence results are undefined.) If the array contains multiple elements equal to the specified object, there is no guarantee which one will be found.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "binarySearch(java.lang.Object[] a, int fromIndex, int toIndex, java.lang.Object key)",
    "name": "binarySearch",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "key"
      }
    ],
    "protocol": {
      "member": "binarySearch(java.lang.Object[] a, int fromIndex, int toIndex, java.lang.Object key)",
      "comment": "Searches a range of the specified array for the specified object using the binary search algorithm. The range must be sorted into ascending order according to the Comparable natural ordering of its elements (as by the method_0 method) prior to making this call. If it is not sorted, the results are undefined. (If the range contains elements that are not mutually comparable (for example, strings and integers), it cannot be sorted according to the natural ordering of its elements, hence results are undefined.) If the range contains multiple elements equal to the specified object, there is no guarantee which one will be found.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "binarySearch(T[] a, T key, java.util.Comparator<? super T> c)",
    "name": "binarySearch",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "key"
      },
      {
        "type": {
          "qualifiedName": "java.util.Comparator",
          "name": "Comparator",
          "isArray": false
        },
        "name": "c"
      }
    ],
    "protocol": {
      "member": "binarySearch(T[] a, T key, java.util.Comparator<? super T> c)",
      "comment": "Searches the specified array for the specified object using the binary search algorithm. The array must be sorted into ascending order according to the specified comparator (as by the method_1 method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements equal to the specified object, there is no guarantee which one will be found.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "binarySearch(T[] a, int fromIndex, int toIndex, T key, java.util.Comparator<? super T> c)",
    "name": "binarySearch",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "key"
      },
      {
        "type": {
          "qualifiedName": "java.util.Comparator",
          "name": "Comparator",
          "isArray": false
        },
        "name": "c"
      }
    ],
    "protocol": {
      "member": "binarySearch(T[] a, int fromIndex, int toIndex, T key, java.util.Comparator<? super T> c)",
      "comment": "Searches a range of the specified array for the specified object using the binary search algorithm. The range must be sorted into ascending order according to the specified comparator (as by the method_1 method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements equal to the specified object, there is no guarantee which one will be found.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "equals(long[] a, long[] a2)",
    "name": "equals",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[J",
          "name": "long[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "[J",
          "name": "long[]",
          "isArray": true
        },
        "name": "a2"
      }
    ],
    "protocol": {
      "member": "equals(long[] a, long[] a2)",
      "comment": "Returns true if the two specified arrays of longs are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "equals(int[] a, int[] a2)",
    "name": "equals",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[I",
          "name": "int[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "[I",
          "name": "int[]",
          "isArray": true
        },
        "name": "a2"
      }
    ],
    "protocol": {
      "member": "equals(int[] a, int[] a2)",
      "comment": "Returns true if the two specified arrays of ints are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "equals(short[] a, short[] a2)",
    "name": "equals",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[S",
          "name": "short[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "[S",
          "name": "short[]",
          "isArray": true
        },
        "name": "a2"
      }
    ],
    "protocol": {
      "member": "equals(short[] a, short[] a2)",
      "comment": "Returns true if the two specified arrays of shorts are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "equals(char[] a, char[] a2)",
    "name": "equals",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[C",
          "name": "char[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "[C",
          "name": "char[]",
          "isArray": true
        },
        "name": "a2"
      }
    ],
    "protocol": {
      "member": "equals(char[] a, char[] a2)",
      "comment": "Returns true if the two specified arrays of chars are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "equals(byte[] a, byte[] a2)",
    "name": "equals",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[B",
          "name": "byte[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "[B",
          "name": "byte[]",
          "isArray": true
        },
        "name": "a2"
      }
    ],
    "protocol": {
      "member": "equals(byte[] a, byte[] a2)",
      "comment": "Returns true if the two specified arrays of bytes are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "equals(boolean[] a, boolean[] a2)",
    "name": "equals",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Z",
          "name": "boolean[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "[Z",
          "name": "boolean[]",
          "isArray": true
        },
        "name": "a2"
      }
    ],
    "protocol": {
      "member": "equals(boolean[] a, boolean[] a2)",
      "comment": "Returns true if the two specified arrays of booleans are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "equals(double[] a, double[] a2)",
    "name": "equals",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "a2"
      }
    ],
    "protocol": {
      "member": "equals(double[] a, double[] a2)",
      "comment": "Returns true if the two specified arrays of doubles are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null. Two doubles d1 and d2 are considered equal if:  <tt>method_0method_1</tt> (Unlike the == operator, this method considers NaN equals to itself, and 0method_3 unequal to -0method_3.)",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "equals(float[] a, float[] a2)",
    "name": "equals",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[F",
          "name": "float[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "[F",
          "name": "float[]",
          "isArray": true
        },
        "name": "a2"
      }
    ],
    "protocol": {
      "member": "equals(float[] a, float[] a2)",
      "comment": "Returns true if the two specified arrays of floats are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null. Two floats f1 and f2 are considered equal if:  <tt>method_0method_1</tt> (Unlike the == operator, this method considers NaN equals to itself, and 0method_3 unequal to -0method_3.)",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "equals(java.lang.Object[] a, java.lang.Object[] a2)",
    "name": "equals",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "a2"
      }
    ],
    "protocol": {
      "member": "equals(java.lang.Object[] a, java.lang.Object[] a2)",
      "comment": "Returns true if the two specified arrays of Objects are equal to one another. The two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. Two objects e1 and e2 are considered equal if (e1==null ? e2==null : method_0. In other words, the two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "fill(long[] a, long val)",
    "name": "fill",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[J",
          "name": "long[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "long",
          "name": "long",
          "isArray": false
        },
        "name": "val"
      }
    ],
    "protocol": {
      "member": "fill(long[] a, long val)",
      "comment": "Assigns the specified long value to each element of the specified array of longs.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "fill(long[] a, int fromIndex, int toIndex, long val)",
    "name": "fill",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[J",
          "name": "long[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "long",
          "name": "long",
          "isArray": false
        },
        "name": "val"
      }
    ],
    "protocol": {
      "member": "fill(long[] a, int fromIndex, int toIndex, long val)",
      "comment": "Assigns the specified long value to each element of the specified range of the specified array of longs. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be filled is empty.)",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "fill(int[] a, int val)",
    "name": "fill",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[I",
          "name": "int[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "val"
      }
    ],
    "protocol": {
      "member": "fill(int[] a, int val)",
      "comment": "Assigns the specified int value to each element of the specified array of ints.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "fill(int[] a, int fromIndex, int toIndex, int val)",
    "name": "fill",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[I",
          "name": "int[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "val"
      }
    ],
    "protocol": {
      "member": "fill(int[] a, int fromIndex, int toIndex, int val)",
      "comment": "Assigns the specified int value to each element of the specified range of the specified array of ints. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be filled is empty.)",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "fill(short[] a, short val)",
    "name": "fill",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[S",
          "name": "short[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "short",
          "name": "short",
          "isArray": false
        },
        "name": "val"
      }
    ],
    "protocol": {
      "member": "fill(short[] a, short val)",
      "comment": "Assigns the specified short value to each element of the specified array of shorts.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "fill(short[] a, int fromIndex, int toIndex, short val)",
    "name": "fill",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[S",
          "name": "short[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "short",
          "name": "short",
          "isArray": false
        },
        "name": "val"
      }
    ],
    "protocol": {
      "member": "fill(short[] a, int fromIndex, int toIndex, short val)",
      "comment": "Assigns the specified short value to each element of the specified range of the specified array of shorts. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be filled is empty.)",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "fill(char[] a, char val)",
    "name": "fill",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[C",
          "name": "char[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "char",
          "name": "char",
          "isArray": false
        },
        "name": "val"
      }
    ],
    "protocol": {
      "member": "fill(char[] a, char val)",
      "comment": "Assigns the specified char value to each element of the specified array of chars.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "fill(char[] a, int fromIndex, int toIndex, char val)",
    "name": "fill",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[C",
          "name": "char[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "char",
          "name": "char",
          "isArray": false
        },
        "name": "val"
      }
    ],
    "protocol": {
      "member": "fill(char[] a, int fromIndex, int toIndex, char val)",
      "comment": "Assigns the specified char value to each element of the specified range of the specified array of chars. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be filled is empty.)",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "fill(byte[] a, byte val)",
    "name": "fill",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[B",
          "name": "byte[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "byte",
          "name": "byte",
          "isArray": false
        },
        "name": "val"
      }
    ],
    "protocol": {
      "member": "fill(byte[] a, byte val)",
      "comment": "Assigns the specified byte value to each element of the specified array of bytes.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "fill(byte[] a, int fromIndex, int toIndex, byte val)",
    "name": "fill",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[B",
          "name": "byte[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "byte",
          "name": "byte",
          "isArray": false
        },
        "name": "val"
      }
    ],
    "protocol": {
      "member": "fill(byte[] a, int fromIndex, int toIndex, byte val)",
      "comment": "Assigns the specified byte value to each element of the specified range of the specified array of bytes. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be filled is empty.)",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "fill(boolean[] a, boolean val)",
    "name": "fill",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Z",
          "name": "boolean[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "boolean",
          "name": "boolean",
          "isArray": false
        },
        "name": "val"
      }
    ],
    "protocol": {
      "member": "fill(boolean[] a, boolean val)",
      "comment": "Assigns the specified boolean value to each element of the specified array of booleans.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "fill(boolean[] a, int fromIndex, int toIndex, boolean val)",
    "name": "fill",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Z",
          "name": "boolean[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "boolean",
          "name": "boolean",
          "isArray": false
        },
        "name": "val"
      }
    ],
    "protocol": {
      "member": "fill(boolean[] a, int fromIndex, int toIndex, boolean val)",
      "comment": "Assigns the specified boolean value to each element of the specified range of the specified array of booleans. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be filled is empty.)",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "fill(double[] a, double val)",
    "name": "fill",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "val"
      }
    ],
    "protocol": {
      "member": "fill(double[] a, double val)",
      "comment": "Assigns the specified double value to each element of the specified array of doubles.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "fill(double[] a, int fromIndex, int toIndex, double val)",
    "name": "fill",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "val"
      }
    ],
    "protocol": {
      "member": "fill(double[] a, int fromIndex, int toIndex, double val)",
      "comment": "Assigns the specified double value to each element of the specified range of the specified array of doubles. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be filled is empty.)",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "fill(float[] a, float val)",
    "name": "fill",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[F",
          "name": "float[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "float",
          "name": "float",
          "isArray": false
        },
        "name": "val"
      }
    ],
    "protocol": {
      "member": "fill(float[] a, float val)",
      "comment": "Assigns the specified float value to each element of the specified array of floats.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "fill(float[] a, int fromIndex, int toIndex, float val)",
    "name": "fill",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[F",
          "name": "float[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "float",
          "name": "float",
          "isArray": false
        },
        "name": "val"
      }
    ],
    "protocol": {
      "member": "fill(float[] a, int fromIndex, int toIndex, float val)",
      "comment": "Assigns the specified float value to each element of the specified range of the specified array of floats. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be filled is empty.)",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "fill(java.lang.Object[] a, java.lang.Object val)",
    "name": "fill",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "val"
      }
    ],
    "protocol": {
      "member": "fill(java.lang.Object[] a, java.lang.Object val)",
      "comment": "Assigns the specified Object reference to each element of the specified array of Objects.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "fill(java.lang.Object[] a, int fromIndex, int toIndex, java.lang.Object val)",
    "name": "fill",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "a"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "val"
      }
    ],
    "protocol": {
      "member": "fill(java.lang.Object[] a, int fromIndex, int toIndex, java.lang.Object val)",
      "comment": "Assigns the specified Object reference to each element of the specified range of the specified array of Objects. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be filled is empty.)",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "copyOf(T[] original, int newLength)",
    "name": "copyOf",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "T[]",
      "name": "T[]",
      "isArray": true
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "original"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "newLength"
      }
    ],
    "protocol": {
      "member": "copyOf(T[] original, int newLength)",
      "comment": "Copies the specified array, truncating or padding with nulls (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain null. Such indices will exist if and only if the specified length is greater than that of the original array. The resulting array is of exactly the same class as the original array.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "copyOf(U[] original, int newLength, java.lang.Class<? extends T[]> newType)",
    "name": "copyOf",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "T[]",
      "name": "T[]",
      "isArray": true
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "original"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "newLength"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Class",
          "name": "Class",
          "isArray": false
        },
        "name": "newType"
      }
    ],
    "protocol": {
      "member": "copyOf(U[] original, int newLength, java.lang.Class<? extends T[]> newType)",
      "comment": "Copies the specified array, truncating or padding with nulls (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain null. Such indices will exist if and only if the specified length is greater than that of the original array. The resulting array is of the class newType.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "copyOf(byte[] original, int newLength)",
    "name": "copyOf",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "byte[]",
      "name": "byte[]",
      "isArray": true
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[B",
          "name": "byte[]",
          "isArray": true
        },
        "name": "original"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "newLength"
      }
    ],
    "protocol": {
      "member": "copyOf(byte[] original, int newLength)",
      "comment": "Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain (byte)0. Such indices will exist if and only if the specified length is greater than that of the original array.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "copyOf(short[] original, int newLength)",
    "name": "copyOf",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "short[]",
      "name": "short[]",
      "isArray": true
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[S",
          "name": "short[]",
          "isArray": true
        },
        "name": "original"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "newLength"
      }
    ],
    "protocol": {
      "member": "copyOf(short[] original, int newLength)",
      "comment": "Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain (short)0. Such indices will exist if and only if the specified length is greater than that of the original array.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "copyOf(int[] original, int newLength)",
    "name": "copyOf",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int[]",
      "name": "int[]",
      "isArray": true
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[I",
          "name": "int[]",
          "isArray": true
        },
        "name": "original"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "newLength"
      }
    ],
    "protocol": {
      "member": "copyOf(int[] original, int newLength)",
      "comment": "Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain 0. Such indices will exist if and only if the specified length is greater than that of the original array.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "copyOf(long[] original, int newLength)",
    "name": "copyOf",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "long[]",
      "name": "long[]",
      "isArray": true
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[J",
          "name": "long[]",
          "isArray": true
        },
        "name": "original"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "newLength"
      }
    ],
    "protocol": {
      "member": "copyOf(long[] original, int newLength)",
      "comment": "Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain 0L. Such indices will exist if and only if the specified length is greater than that of the original array.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "copyOf(char[] original, int newLength)",
    "name": "copyOf",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "char[]",
      "name": "char[]",
      "isArray": true
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[C",
          "name": "char[]",
          "isArray": true
        },
        "name": "original"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "newLength"
      }
    ],
    "protocol": {
      "member": "copyOf(char[] original, int newLength)",
      "comment": "Copies the specified array, truncating or padding with null characters (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain '\\\\u000'. Such indices will exist if and only if the specified length is greater than that of the original array.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "copyOf(float[] original, int newLength)",
    "name": "copyOf",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "float[]",
      "name": "float[]",
      "isArray": true
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[F",
          "name": "float[]",
          "isArray": true
        },
        "name": "original"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "newLength"
      }
    ],
    "protocol": {
      "member": "copyOf(float[] original, int newLength)",
      "comment": "Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain 0f. Such indices will exist if and only if the specified length is greater than that of the original array.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "copyOf(double[] original, int newLength)",
    "name": "copyOf",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "double[]",
      "name": "double[]",
      "isArray": true
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "original"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "newLength"
      }
    ],
    "protocol": {
      "member": "copyOf(double[] original, int newLength)",
      "comment": "Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain 0d. Such indices will exist if and only if the specified length is greater than that of the original array.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "copyOf(boolean[] original, int newLength)",
    "name": "copyOf",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean[]",
      "name": "boolean[]",
      "isArray": true
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Z",
          "name": "boolean[]",
          "isArray": true
        },
        "name": "original"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "newLength"
      }
    ],
    "protocol": {
      "member": "copyOf(boolean[] original, int newLength)",
      "comment": "Copies the specified array, truncating or padding with false (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain false. Such indices will exist if and only if the specified length is greater than that of the original array.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "copyOfRange(T[] original, int from, int to)",
    "name": "copyOfRange",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "T[]",
      "name": "T[]",
      "isArray": true
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "original"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "from"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "to"
      }
    ],
    "protocol": {
      "member": "copyOfRange(T[] original, int from, int to)",
      "comment": "Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and originalmethod_0, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == originalmethod_0 or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than originalmethod_0, in which case null is placed in all elements of the copy whose index is greater than or equal to originalmethod_0 - from. The length of the returned array will be to - from.  The resulting array is of exactly the same class as the original array.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "copyOfRange(U[] original, int from, int to, java.lang.Class<? extends T[]> newType)",
    "name": "copyOfRange",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "T[]",
      "name": "T[]",
      "isArray": true
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "original"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "from"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "to"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Class",
          "name": "Class",
          "isArray": false
        },
        "name": "newType"
      }
    ],
    "protocol": {
      "member": "copyOfRange(U[] original, int from, int to, java.lang.Class<? extends T[]> newType)",
      "comment": "Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and originalmethod_0, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == originalmethod_0 or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than originalmethod_0, in which case null is placed in all elements of the copy whose index is greater than or equal to originalmethod_0 - from. The length of the returned array will be to - from. The resulting array is of the class newType.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "copyOfRange(byte[] original, int from, int to)",
    "name": "copyOfRange",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "byte[]",
      "name": "byte[]",
      "isArray": true
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[B",
          "name": "byte[]",
          "isArray": true
        },
        "name": "original"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "from"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "to"
      }
    ],
    "protocol": {
      "member": "copyOfRange(byte[] original, int from, int to)",
      "comment": "Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and originalmethod_0, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == originalmethod_0 or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than originalmethod_0, in which case (byte)0 is placed in all elements of the copy whose index is greater than or equal to originalmethod_0 - from. The length of the returned array will be to - from.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "copyOfRange(short[] original, int from, int to)",
    "name": "copyOfRange",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "short[]",
      "name": "short[]",
      "isArray": true
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[S",
          "name": "short[]",
          "isArray": true
        },
        "name": "original"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "from"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "to"
      }
    ],
    "protocol": {
      "member": "copyOfRange(short[] original, int from, int to)",
      "comment": "Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and originalmethod_0, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == originalmethod_0 or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than originalmethod_0, in which case (short)0 is placed in all elements of the copy whose index is greater than or equal to originalmethod_0 - from. The length of the returned array will be to - from.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "copyOfRange(int[] original, int from, int to)",
    "name": "copyOfRange",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int[]",
      "name": "int[]",
      "isArray": true
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[I",
          "name": "int[]",
          "isArray": true
        },
        "name": "original"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "from"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "to"
      }
    ],
    "protocol": {
      "member": "copyOfRange(int[] original, int from, int to)",
      "comment": "Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and originalmethod_0, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == originalmethod_0 or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than originalmethod_0, in which case 0 is placed in all elements of the copy whose index is greater than or equal to originalmethod_0 - from. The length of the returned array will be to - from.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "copyOfRange(long[] original, int from, int to)",
    "name": "copyOfRange",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "long[]",
      "name": "long[]",
      "isArray": true
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[J",
          "name": "long[]",
          "isArray": true
        },
        "name": "original"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "from"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "to"
      }
    ],
    "protocol": {
      "member": "copyOfRange(long[] original, int from, int to)",
      "comment": "Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and originalmethod_0, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == originalmethod_0 or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than originalmethod_0, in which case 0L is placed in all elements of the copy whose index is greater than or equal to originalmethod_0 - from. The length of the returned array will be to - from.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "copyOfRange(char[] original, int from, int to)",
    "name": "copyOfRange",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "char[]",
      "name": "char[]",
      "isArray": true
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[C",
          "name": "char[]",
          "isArray": true
        },
        "name": "original"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "from"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "to"
      }
    ],
    "protocol": {
      "member": "copyOfRange(char[] original, int from, int to)",
      "comment": "Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and originalmethod_0, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == originalmethod_0 or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than originalmethod_0, in which case '\\\\u000' is placed in all elements of the copy whose index is greater than or equal to originalmethod_0 - from. The length of the returned array will be to - from.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "copyOfRange(float[] original, int from, int to)",
    "name": "copyOfRange",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "float[]",
      "name": "float[]",
      "isArray": true
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[F",
          "name": "float[]",
          "isArray": true
        },
        "name": "original"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "from"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "to"
      }
    ],
    "protocol": {
      "member": "copyOfRange(float[] original, int from, int to)",
      "comment": "Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and originalmethod_0, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == originalmethod_0 or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than originalmethod_0, in which case 0f is placed in all elements of the copy whose index is greater than or equal to originalmethod_0 - from. The length of the returned array will be to - from.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "copyOfRange(double[] original, int from, int to)",
    "name": "copyOfRange",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "double[]",
      "name": "double[]",
      "isArray": true
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "original"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "from"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "to"
      }
    ],
    "protocol": {
      "member": "copyOfRange(double[] original, int from, int to)",
      "comment": "Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and originalmethod_0, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == originalmethod_0 or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than originalmethod_0, in which case 0d is placed in all elements of the copy whose index is greater than or equal to originalmethod_0 - from. The length of the returned array will be to - from.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "copyOfRange(boolean[] original, int from, int to)",
    "name": "copyOfRange",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean[]",
      "name": "boolean[]",
      "isArray": true
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Z",
          "name": "boolean[]",
          "isArray": true
        },
        "name": "original"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "from"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "to"
      }
    ],
    "protocol": {
      "member": "copyOfRange(boolean[] original, int from, int to)",
      "comment": "Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and originalmethod_0, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == originalmethod_0 or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than originalmethod_0, in which case false is placed in all elements of the copy whose index is greater than or equal to originalmethod_0 - from. The length of the returned array will be to - from.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "asList(T... a)",
    "name": "asList",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": true,
    "returnType": {
      "qualifiedName": "java.util.List<T>",
      "name": "java.util.List<T>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "asList(T... a)",
      "comment": "Returns a fixed-size list backed by the specified array. (Changes to the returned list \"write through\" to the array.) This method acts as bridge between array-based and collection-based APIs, in combination with method_1. The returned list is serializable and implements RandomAccess. This method also provides a convenient way to create a fixed-size list initialized to contain several elements:  List<String> stooges = method_0;",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "hashCode(long[] a)",
    "name": "hashCode",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[J",
          "name": "long[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "hashCode(long[] a)",
      "comment": "Returns a hash code based on the contents of the specified array. For any two long arrays a and b such that method_0, it is also the case that method_1 == method_2. The value returned by this method is the same value that would be obtained by invoking the method_3 hashCode method on a List containing a sequence of Long instances representing the elements of a in the same order. If a is null, this method returns 0.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "hashCode(int[] a)",
    "name": "hashCode",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[I",
          "name": "int[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "hashCode(int[] a)",
      "comment": "Returns a hash code based on the contents of the specified array. For any two non-null int arrays a and b such that method_0, it is also the case that method_1 == method_2. The value returned by this method is the same value that would be obtained by invoking the method_3 hashCode method on a List containing a sequence of Integer instances representing the elements of a in the same order. If a is null, this method returns 0.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "hashCode(short[] a)",
    "name": "hashCode",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[S",
          "name": "short[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "hashCode(short[] a)",
      "comment": "Returns a hash code based on the contents of the specified array. For any two short arrays a and b such that method_0, it is also the case that method_1 == method_2. The value returned by this method is the same value that would be obtained by invoking the method_3 hashCode method on a List containing a sequence of Short instances representing the elements of a in the same order. If a is null, this method returns 0.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "hashCode(char[] a)",
    "name": "hashCode",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[C",
          "name": "char[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "hashCode(char[] a)",
      "comment": "Returns a hash code based on the contents of the specified array. For any two char arrays a and b such that method_0, it is also the case that method_1 == method_2. The value returned by this method is the same value that would be obtained by invoking the method_3 hashCode method on a List containing a sequence of Character instances representing the elements of a in the same order. If a is null, this method returns 0.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "hashCode(byte[] a)",
    "name": "hashCode",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[B",
          "name": "byte[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "hashCode(byte[] a)",
      "comment": "Returns a hash code based on the contents of the specified array. For any two byte arrays a and b such that method_0, it is also the case that method_1 == method_2. The value returned by this method is the same value that would be obtained by invoking the method_3 hashCode method on a List containing a sequence of Byte instances representing the elements of a in the same order. If a is null, this method returns 0.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "hashCode(boolean[] a)",
    "name": "hashCode",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Z",
          "name": "boolean[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "hashCode(boolean[] a)",
      "comment": "Returns a hash code based on the contents of the specified array. For any two boolean arrays a and b such that method_0, it is also the case that method_1 == method_2. The value returned by this method is the same value that would be obtained by invoking the method_3 hashCode method on a List containing a sequence of Boolean instances representing the elements of a in the same order. If a is null, this method returns 0.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "hashCode(float[] a)",
    "name": "hashCode",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[F",
          "name": "float[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "hashCode(float[] a)",
      "comment": "Returns a hash code based on the contents of the specified array. For any two float arrays a and b such that method_0, it is also the case that method_1 == method_2. The value returned by this method is the same value that would be obtained by invoking the method_3 hashCode method on a List containing a sequence of Float instances representing the elements of a in the same order. If a is null, this method returns 0.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "hashCode(double[] a)",
    "name": "hashCode",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "hashCode(double[] a)",
      "comment": "Returns a hash code based on the contents of the specified array. For any two double arrays a and b such that method_0, it is also the case that method_1 == method_2. The value returned by this method is the same value that would be obtained by invoking the method_3 hashCode method on a List containing a sequence of Double instances representing the elements of a in the same order. If a is null, this method returns 0.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "hashCode(java.lang.Object[] a)",
    "name": "hashCode",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "hashCode(java.lang.Object[] a)",
      "comment": "Returns a hash code based on the contents of the specified array. If the array contains other arrays as elements, the hash code is based on their identities rather than their contents. It is therefore acceptable to invoke this method on an array that contains itself as an element, either directly or indirectly through one or more levels of arrays. For any two arrays a and b such that method_0, it is also the case that method_1 == method_2. The value returned by this method is equal to the value that would be returned by method_3method_4, unless a is null, in which case 0 is returned.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "deepHashCode(java.lang.Object[] a)",
    "name": "deepHashCode",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "deepHashCode(java.lang.Object[] a)",
      "comment": "Returns a hash code based on the \"deep contents\" of the specified array. If the array contains other arrays as elements, the hash code is based on their contents and so on, ad infinitum. It is therefore unacceptable to invoke this method on an array that contains itself as an element, either directly or indirectly through one or more levels of arrays. The behavior of such an invocation is undefined. For any two arrays a and b such that method_0, it is also the case that method_1 == method_2. The computation of the value returned by this method is similar to that of the value returned by method_3 on a list containing the same elements as a in the same order, with one difference: If an element e of a is itself an array, its hash code is computed not by calling method_4, but as by calling the appropriate overloading of method_5 if e is an array of a primitive type, or as by calling method_6 recursively if e is an array of a reference type. If a is null, this method returns 0.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "deepEquals(java.lang.Object[] a1, java.lang.Object[] a2)",
    "name": "deepEquals",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "a1"
      },
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "a2"
      }
    ],
    "protocol": {
      "member": "deepEquals(java.lang.Object[] a1, java.lang.Object[] a2)",
      "comment": "Returns true if the two specified arrays are deeply equal to one another. Unlike the method_0 method, this method is appropriate for use with nested arrays of arbitrary depth. Two array references are considered deeply equal if both are null, or if they refer to arrays that contain the same number of elements and all corresponding pairs of elements in the two arrays are deeply equal. Two possibly null elements e1 and e2 are deeply equal if any of the following conditions hold: <ul> <li> e1 and e2 are both arrays of object reference types, and <tt>method_1 would return true</tt> <li> e1 and e2 are arrays of the same primitive type, and the appropriate overloading of <tt>method_2</tt> would return true. <li> <tt>e1 == e2</tt> <li> <tt>method_3</tt> would return true. </ul> Note that this definition permits null elements at any depth. If either of the specified arrays contain themselves as elements either directly or indirectly through one or more levels of arrays, the behavior of this method is undefined.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "deepEquals0(java.lang.Object e1, java.lang.Object e2)",
    "name": "deepEquals0",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "e1"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "e2"
      }
    ],
    "protocol": {
      "member": "deepEquals0(java.lang.Object e1, java.lang.Object e2)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "toString(long[] a)",
    "name": "toString",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.lang.String",
      "name": "java.lang.String",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[J",
          "name": "long[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "toString(long[] a)",
      "comment": "Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets (\"[]\"). Adjacent elements are separated by the characters \", \" (a comma followed by a space). Elements are converted to strings as by method_0. Returns \"null\" if a is null.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "toString(int[] a)",
    "name": "toString",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.lang.String",
      "name": "java.lang.String",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[I",
          "name": "int[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "toString(int[] a)",
      "comment": "Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets (\"[]\"). Adjacent elements are separated by the characters \", \" (a comma followed by a space). Elements are converted to strings as by method_0. Returns \"null\" if a is null.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "toString(short[] a)",
    "name": "toString",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.lang.String",
      "name": "java.lang.String",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[S",
          "name": "short[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "toString(short[] a)",
      "comment": "Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets (\"[]\"). Adjacent elements are separated by the characters \", \" (a comma followed by a space). Elements are converted to strings as by method_0. Returns \"null\" if a is null.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "toString(char[] a)",
    "name": "toString",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.lang.String",
      "name": "java.lang.String",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[C",
          "name": "char[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "toString(char[] a)",
      "comment": "Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets (\"[]\"). Adjacent elements are separated by the characters \", \" (a comma followed by a space). Elements are converted to strings as by method_0. Returns \"null\" if a is null.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "toString(byte[] a)",
    "name": "toString",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.lang.String",
      "name": "java.lang.String",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[B",
          "name": "byte[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "toString(byte[] a)",
      "comment": "Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets (\"[]\"). Adjacent elements are separated by the characters \", \" (a comma followed by a space). Elements are converted to strings as by method_0. Returns \"null\" if a is null.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "toString(boolean[] a)",
    "name": "toString",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.lang.String",
      "name": "java.lang.String",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Z",
          "name": "boolean[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "toString(boolean[] a)",
      "comment": "Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets (\"[]\"). Adjacent elements are separated by the characters \", \" (a comma followed by a space). Elements are converted to strings as by method_0. Returns \"null\" if a is null.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "toString(float[] a)",
    "name": "toString",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.lang.String",
      "name": "java.lang.String",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[F",
          "name": "float[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "toString(float[] a)",
      "comment": "Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets (\"[]\"). Adjacent elements are separated by the characters \", \" (a comma followed by a space). Elements are converted to strings as by method_0. Returns \"null\" if a is null.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "toString(double[] a)",
    "name": "toString",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.lang.String",
      "name": "java.lang.String",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "toString(double[] a)",
      "comment": "Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets (\"[]\"). Adjacent elements are separated by the characters \", \" (a comma followed by a space). Elements are converted to strings as by method_0. Returns \"null\" if a is null.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "toString(java.lang.Object[] a)",
    "name": "toString",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.lang.String",
      "name": "java.lang.String",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "toString(java.lang.Object[] a)",
      "comment": "Returns a string representation of the contents of the specified array. If the array contains other arrays as elements, they are converted to strings by the method_2 method inherited from Object, which describes their identities rather than their contents. The value returned by this method is equal to the value that would be returned by method_0method_1, unless a is null, in which case \"null\" is returned.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "deepToString(java.lang.Object[] a)",
    "name": "deepToString",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.lang.String",
      "name": "java.lang.String",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "a"
      }
    ],
    "protocol": {
      "member": "deepToString(java.lang.Object[] a)",
      "comment": "Returns a string representation of the \"deep contents\" of the specified array. If the array contains other arrays as elements, the string representation contains their contents and so on. This method is designed for converting multidimensional arrays to strings. The string representation consists of a list of the array's elements, enclosed in square brackets (\"[]\"). Adjacent elements are separated by the characters \", \" (a comma followed by a space). Elements are converted to strings as by method_0, unless they are themselves arrays. If an element e is an array of a primitive type, it is converted to a string as by invoking the appropriate overloading of method_1. If an element e is an array of a reference type, it is converted to a string as by invoking this method recursively. To avoid infinite recursion, if the specified array contains itself as an element, or contains an indirect reference to itself through one or more levels of arrays, the self-reference is converted to the string \"[...]\". For example, an array containing only a reference to itself would be rendered as \"[[...]]\". This method returns \"null\" if the specified array is null.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "setAll(T[] array, java.util.function.IntFunction<? extends T> generator)",
    "name": "setAll",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "array"
      },
      {
        "type": {
          "qualifiedName": "java.util.function.IntFunction",
          "name": "IntFunction",
          "isArray": false
        },
        "name": "generator"
      }
    ],
    "protocol": {
      "member": "setAll(T[] array, java.util.function.IntFunction<? extends T> generator)",
      "comment": "Set all elements of the specified array, using the provided generator function to compute each element. If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "parallelSetAll(T[] array, java.util.function.IntFunction<? extends T> generator)",
    "name": "parallelSetAll",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "array"
      },
      {
        "type": {
          "qualifiedName": "java.util.function.IntFunction",
          "name": "IntFunction",
          "isArray": false
        },
        "name": "generator"
      }
    ],
    "protocol": {
      "member": "parallelSetAll(T[] array, java.util.function.IntFunction<? extends T> generator)",
      "comment": "Set all elements of the specified array, in parallel, using the provided generator function to compute each element. If the generator function throws an exception, an unchecked exception is thrown from parallelSetAll and the array is left in an indeterminate state.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "setAll(int[] array, java.util.function.IntUnaryOperator generator)",
    "name": "setAll",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[I",
          "name": "int[]",
          "isArray": true
        },
        "name": "array"
      },
      {
        "type": {
          "qualifiedName": "java.util.function.IntUnaryOperator",
          "name": "IntUnaryOperator",
          "isArray": false
        },
        "name": "generator"
      }
    ],
    "protocol": {
      "member": "setAll(int[] array, java.util.function.IntUnaryOperator generator)",
      "comment": "Set all elements of the specified array, using the provided generator function to compute each element. If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "parallelSetAll(int[] array, java.util.function.IntUnaryOperator generator)",
    "name": "parallelSetAll",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[I",
          "name": "int[]",
          "isArray": true
        },
        "name": "array"
      },
      {
        "type": {
          "qualifiedName": "java.util.function.IntUnaryOperator",
          "name": "IntUnaryOperator",
          "isArray": false
        },
        "name": "generator"
      }
    ],
    "protocol": {
      "member": "parallelSetAll(int[] array, java.util.function.IntUnaryOperator generator)",
      "comment": "Set all elements of the specified array, in parallel, using the provided generator function to compute each element. If the generator function throws an exception, an unchecked exception is thrown from parallelSetAll and the array is left in an indeterminate state.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "setAll(long[] array, java.util.function.IntToLongFunction generator)",
    "name": "setAll",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[J",
          "name": "long[]",
          "isArray": true
        },
        "name": "array"
      },
      {
        "type": {
          "qualifiedName": "java.util.function.IntToLongFunction",
          "name": "IntToLongFunction",
          "isArray": false
        },
        "name": "generator"
      }
    ],
    "protocol": {
      "member": "setAll(long[] array, java.util.function.IntToLongFunction generator)",
      "comment": "Set all elements of the specified array, using the provided generator function to compute each element. If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "parallelSetAll(long[] array, java.util.function.IntToLongFunction generator)",
    "name": "parallelSetAll",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[J",
          "name": "long[]",
          "isArray": true
        },
        "name": "array"
      },
      {
        "type": {
          "qualifiedName": "java.util.function.IntToLongFunction",
          "name": "IntToLongFunction",
          "isArray": false
        },
        "name": "generator"
      }
    ],
    "protocol": {
      "member": "parallelSetAll(long[] array, java.util.function.IntToLongFunction generator)",
      "comment": "Set all elements of the specified array, in parallel, using the provided generator function to compute each element. If the generator function throws an exception, an unchecked exception is thrown from parallelSetAll and the array is left in an indeterminate state.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "setAll(double[] array, java.util.function.IntToDoubleFunction generator)",
    "name": "setAll",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "array"
      },
      {
        "type": {
          "qualifiedName": "java.util.function.IntToDoubleFunction",
          "name": "IntToDoubleFunction",
          "isArray": false
        },
        "name": "generator"
      }
    ],
    "protocol": {
      "member": "setAll(double[] array, java.util.function.IntToDoubleFunction generator)",
      "comment": "Set all elements of the specified array, using the provided generator function to compute each element. If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "parallelSetAll(double[] array, java.util.function.IntToDoubleFunction generator)",
    "name": "parallelSetAll",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "array"
      },
      {
        "type": {
          "qualifiedName": "java.util.function.IntToDoubleFunction",
          "name": "IntToDoubleFunction",
          "isArray": false
        },
        "name": "generator"
      }
    ],
    "protocol": {
      "member": "parallelSetAll(double[] array, java.util.function.IntToDoubleFunction generator)",
      "comment": "Set all elements of the specified array, in parallel, using the provided generator function to compute each element. If the generator function throws an exception, an unchecked exception is thrown from parallelSetAll and the array is left in an indeterminate state.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "spliterator(T[] array)",
    "name": "spliterator",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.Spliterator<T>",
      "name": "java.util.Spliterator<T>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "array"
      }
    ],
    "protocol": {
      "member": "spliterator(T[] array)",
      "comment": "Returns a Spliterator covering all of the specified array. The spliterator reports method_0, method_1, method_2, and method_3.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "spliterator(T[] array, int startInclusive, int endExclusive)",
    "name": "spliterator",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.Spliterator<T>",
      "name": "java.util.Spliterator<T>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "array"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "startInclusive"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "endExclusive"
      }
    ],
    "protocol": {
      "member": "spliterator(T[] array, int startInclusive, int endExclusive)",
      "comment": "Returns a Spliterator covering the specified range of the specified array. The spliterator reports method_0, method_1, method_2, and method_3.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "spliterator(int[] array)",
    "name": "spliterator",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.Spliterator$OfInt",
      "name": "java.util.Spliterator$OfInt",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[I",
          "name": "int[]",
          "isArray": true
        },
        "name": "array"
      }
    ],
    "protocol": {
      "member": "spliterator(int[] array)",
      "comment": "Returns a method_0 covering all of the specified array. The spliterator reports method_1, method_2, method_3, and method_4.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "spliterator(int[] array, int startInclusive, int endExclusive)",
    "name": "spliterator",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.Spliterator$OfInt",
      "name": "java.util.Spliterator$OfInt",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[I",
          "name": "int[]",
          "isArray": true
        },
        "name": "array"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "startInclusive"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "endExclusive"
      }
    ],
    "protocol": {
      "member": "spliterator(int[] array, int startInclusive, int endExclusive)",
      "comment": "Returns a method_0 covering the specified range of the specified array. The spliterator reports method_1, method_2, method_3, and method_4.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "spliterator(long[] array)",
    "name": "spliterator",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.Spliterator$OfLong",
      "name": "java.util.Spliterator$OfLong",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[J",
          "name": "long[]",
          "isArray": true
        },
        "name": "array"
      }
    ],
    "protocol": {
      "member": "spliterator(long[] array)",
      "comment": "Returns a method_0 covering all of the specified array. The spliterator reports method_1, method_2, method_3, and method_4.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "spliterator(long[] array, int startInclusive, int endExclusive)",
    "name": "spliterator",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.Spliterator$OfLong",
      "name": "java.util.Spliterator$OfLong",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[J",
          "name": "long[]",
          "isArray": true
        },
        "name": "array"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "startInclusive"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "endExclusive"
      }
    ],
    "protocol": {
      "member": "spliterator(long[] array, int startInclusive, int endExclusive)",
      "comment": "Returns a method_0 covering the specified range of the specified array. The spliterator reports method_1, method_2, method_3, and method_4.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "spliterator(double[] array)",
    "name": "spliterator",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.Spliterator$OfDouble",
      "name": "java.util.Spliterator$OfDouble",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "array"
      }
    ],
    "protocol": {
      "member": "spliterator(double[] array)",
      "comment": "Returns a method_0 covering all of the specified array. The spliterator reports method_1, method_2, method_3, and method_4.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "spliterator(double[] array, int startInclusive, int endExclusive)",
    "name": "spliterator",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.Spliterator$OfDouble",
      "name": "java.util.Spliterator$OfDouble",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "array"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "startInclusive"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "endExclusive"
      }
    ],
    "protocol": {
      "member": "spliterator(double[] array, int startInclusive, int endExclusive)",
      "comment": "Returns a method_0 covering the specified range of the specified array. The spliterator reports method_1, method_2, method_3, and method_4.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "stream(T[] array)",
    "name": "stream",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.stream.Stream<T>",
      "name": "java.util.stream.Stream<T>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "array"
      }
    ],
    "protocol": {
      "member": "stream(T[] array)",
      "comment": "Returns a sequential Stream with the specified array as its source.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "stream(T[] array, int startInclusive, int endExclusive)",
    "name": "stream",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.stream.Stream<T>",
      "name": "java.util.stream.Stream<T>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "array"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "startInclusive"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "endExclusive"
      }
    ],
    "protocol": {
      "member": "stream(T[] array, int startInclusive, int endExclusive)",
      "comment": "Returns a sequential Stream with the specified range of the specified array as its source.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "stream(int[] array)",
    "name": "stream",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.stream.IntStream",
      "name": "java.util.stream.IntStream",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[I",
          "name": "int[]",
          "isArray": true
        },
        "name": "array"
      }
    ],
    "protocol": {
      "member": "stream(int[] array)",
      "comment": "Returns a sequential IntStream with the specified array as its source.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "stream(int[] array, int startInclusive, int endExclusive)",
    "name": "stream",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.stream.IntStream",
      "name": "java.util.stream.IntStream",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[I",
          "name": "int[]",
          "isArray": true
        },
        "name": "array"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "startInclusive"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "endExclusive"
      }
    ],
    "protocol": {
      "member": "stream(int[] array, int startInclusive, int endExclusive)",
      "comment": "Returns a sequential IntStream with the specified range of the specified array as its source.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "stream(long[] array)",
    "name": "stream",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.stream.LongStream",
      "name": "java.util.stream.LongStream",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[J",
          "name": "long[]",
          "isArray": true
        },
        "name": "array"
      }
    ],
    "protocol": {
      "member": "stream(long[] array)",
      "comment": "Returns a sequential LongStream with the specified array as its source.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "stream(long[] array, int startInclusive, int endExclusive)",
    "name": "stream",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.stream.LongStream",
      "name": "java.util.stream.LongStream",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[J",
          "name": "long[]",
          "isArray": true
        },
        "name": "array"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "startInclusive"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "endExclusive"
      }
    ],
    "protocol": {
      "member": "stream(long[] array, int startInclusive, int endExclusive)",
      "comment": "Returns a sequential LongStream with the specified range of the specified array as its source.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "stream(double[] array)",
    "name": "stream",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.stream.DoubleStream",
      "name": "java.util.stream.DoubleStream",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "array"
      }
    ],
    "protocol": {
      "member": "stream(double[] array)",
      "comment": "Returns a sequential DoubleStream with the specified array as its source.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "stream(double[] array, int startInclusive, int endExclusive)",
    "name": "stream",
    "containingClass": {
      "qualifiedName": "java.util.Arrays",
      "name": "Arrays",
      "isArray": false
    },
    "targetClass": "java.util.Arrays",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.stream.DoubleStream",
      "name": "java.util.stream.DoubleStream",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "array"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "startInclusive"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "endExclusive"
      }
    ],
    "protocol": {
      "member": "stream(double[] array, int startInclusive, int endExclusive)",
      "comment": "Returns a sequential DoubleStream with the specified range of the specified array as its source.",
      "kind": "FreeText",
      "condition": ""
    }
  }
]