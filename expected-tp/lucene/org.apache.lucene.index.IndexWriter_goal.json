[
  {
    "signature": "org.apache.lucene.index.IndexWriter(org.apache.lucene.store.Directory d, org.apache.lucene.index.IndexWriterConfig conf)",
    "name": "org.apache.lucene.index.IndexWriter",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "parameters": [
      {
        "type": {
          "qualifiedName": "org.apache.lucene.store.Directory",
          "name": "Directory",
          "isArray": false
        },
        "name": "d"
      },
      {
        "type": {
          "qualifiedName": "org.apache.lucene.index.IndexWriterConfig",
          "name": "IndexWriterConfig",
          "isArray": false
        },
        "name": "conf"
      }
    ],
    "protocol": {
      "member": "org.apache.lucene.index.IndexWriter(org.apache.lucene.store.Directory d, org.apache.lucene.index.IndexWriterConfig conf)",
      "comment": "Constructs a new IndexWriter per the settings given in conf. If you want to make \"live\" changes to this writer instance, use #method_0  NOTE: after ths writer is created, the given configuration instance cannot be passed to another writer.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "setMaxDocs(int maxDocs)",
    "name": "setMaxDocs",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "maxDocs"
      }
    ],
    "protocol": {
      "member": "setMaxDocs(int maxDocs)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getActualMaxDocs()",
    "name": "getActualMaxDocs",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getActualMaxDocs()",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getReader()",
    "name": "getReader",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "org.apache.lucene.index.DirectoryReader",
      "name": "org.apache.lucene.index.DirectoryReader",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getReader()",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getReader(boolean applyAllDeletes, boolean writeAllDeletes)",
    "name": "getReader",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "org.apache.lucene.index.DirectoryReader",
      "name": "org.apache.lucene.index.DirectoryReader",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "boolean",
          "name": "boolean",
          "isArray": false
        },
        "name": "applyAllDeletes"
      },
      {
        "type": {
          "qualifiedName": "boolean",
          "name": "boolean",
          "isArray": false
        },
        "name": "writeAllDeletes"
      }
    ],
    "protocol": {
      "member": "getReader(boolean applyAllDeletes, boolean writeAllDeletes)",
      "comment": "Expert: returns a readonly reader, covering all committed as well as un-committed changes to the index. This provides \"near real-time\" searching, in that changes made during an IndexWriter session can be quickly made available for searching without closing the writer nor calling method_0. Note that this is functionally equivalent to calling {#flush} and then opening a new reader. But the turnaround time of this method should be faster since it avoids the potentially costly method_0. You must close the IndexReader returned by this method once you are done using it. It's <i>near</i> real-time because there is no hard guarantee on how quickly you can get a new reader after making changes with IndexWriter. You'll have to experiment in your situation to determine if it's fast enough. As this is a new and experimental feature, please report back on your findings so we can learn, improve and iterate. The resulting reader supports DirectoryReader#openIfChanged, but that call will simply forward back to this method (though this may change in the future). The very first time this method is called, this writer instance will make every effort to pool the readers that it opens for doing merges, applying deletes, etc. This means additional resources (RAM, file descriptors, CPU time) will be consumed. For lower latency on reopening a reader, you should call IndexWriterConfig#setMergedSegmentWarmer to pre-warm a newly merged segment before it's committed to the index. This is important for minimizing index-to-search delay after a large merge.  If an addIndexes* call is running in another thread, then this reader will only search those segments from the foreign index that have been successfully copied over, so far. <b>NOTE</b>: Once the writer is closed, any outstanding readers may continue to be used. However, if you attempt to reopen any of those readers, you'll hit an AlreadyClosedException. @lucene.experimental",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "ramBytesUsed()",
    "name": "ramBytesUsed",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "long",
      "name": "long",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "ramBytesUsed()",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "numDeletedDocs(org.apache.lucene.index.SegmentCommitInfo info)",
    "name": "numDeletedDocs",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "org.apache.lucene.index.SegmentCommitInfo",
          "name": "SegmentCommitInfo",
          "isArray": false
        },
        "name": "info"
      }
    ],
    "protocol": {
      "member": "numDeletedDocs(org.apache.lucene.index.SegmentCommitInfo info)",
      "comment": "Obtain the number of deleted docs for a pooled reader. If the reader isn't being pooled, the segmentInfo's delCount is returned.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "ensureOpen(boolean failIfClosing)",
    "name": "ensureOpen",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "boolean",
          "name": "boolean",
          "isArray": false
        },
        "name": "failIfClosing"
      }
    ],
    "protocol": {
      "member": "ensureOpen(boolean failIfClosing)",
      "comment": "Used internally to throw an AlreadyClosedException if this IndexWriter has been closed or is in the process of closing.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "ensureOpen()",
    "name": "ensureOpen",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "ensureOpen()",
      "comment": "Used internally to throw an AlreadyClosedException if this IndexWriter has been closed ({@code closed=true}) or is in the process of closing ({@code closing=true}).  Calls method_0",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "readFieldInfos(org.apache.lucene.index.SegmentCommitInfo si)",
    "name": "readFieldInfos",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "org.apache.lucene.index.FieldInfos",
      "name": "org.apache.lucene.index.FieldInfos",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "org.apache.lucene.index.SegmentCommitInfo",
          "name": "SegmentCommitInfo",
          "isArray": false
        },
        "name": "si"
      }
    ],
    "protocol": {
      "member": "readFieldInfos(org.apache.lucene.index.SegmentCommitInfo si)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getConfig()",
    "name": "getConfig",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "org.apache.lucene.index.LiveIndexWriterConfig",
      "name": "org.apache.lucene.index.LiveIndexWriterConfig",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getConfig()",
      "comment": "Returns a LiveIndexWriterConfig, which can be used to query the IndexWriter current settings, as well as modify \"live\" ones.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "close()",
    "name": "close",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "close()",
      "comment": "Closes all open resources and releases the write lock. If IndexWriterConfig#commitOnClose is true, this will attempt to gracefully shut down by writing any changes, waiting for any running merges, committing, and closing. In this case, note that:  <li>If you called prepareCommit but failed to call commit, this method will throw IllegalStateException and the IndexWriter will not be closed.</li> <li>If this method throws any other exception, the IndexWriter will be closed, but changes may have been lost.</li>   Note that this may be a costly operation, so, try to re-use a single writer instead of closing and opening a new one. See #method_0 for caveats about write caching done by some IO devices. <p><b>NOTE</b>: You must ensure no other threads are still making changes at the same time that this method is invoked.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getDirectory()",
    "name": "getDirectory",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "org.apache.lucene.store.Directory",
      "name": "org.apache.lucene.store.Directory",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getDirectory()",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getAnalyzer()",
    "name": "getAnalyzer",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "org.apache.lucene.analysis.Analyzer",
      "name": "org.apache.lucene.analysis.Analyzer",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getAnalyzer()",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "maxDoc()",
    "name": "maxDoc",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "maxDoc()",
      "comment": "docs not yet flushed (still in the RAM buffer), not counting deletions. @see method_0",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "advanceSegmentInfosVersion(long newVersion)",
    "name": "advanceSegmentInfosVersion",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "long",
          "name": "long",
          "isArray": false
        },
        "name": "newVersion"
      }
    ],
    "protocol": {
      "member": "advanceSegmentInfosVersion(long newVersion)",
      "comment": "@lucenemethod_0",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "numDocs()",
    "name": "numDocs",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "numDocs()",
      "comment": "docs not yet flushed (still in the RAM buffer), and including deletions. NOTE: buffered deletions are not counted. If you really need these to be counted you should call #method_0 first. @see #numDocs",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "hasDeletions()",
    "name": "hasDeletions",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "hasDeletions()",
      "comment": "Returns true if this index has deletions (including buffered deletions). Note that this will return true if there are buffered Term/Query deletions, even if it turns out those buffered deletions don't match any documents.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "addDocument(java.lang.Iterable<? extends org.apache.lucene.index.IndexableField> doc)",
    "name": "addDocument",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "long",
      "name": "long",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Iterable",
          "name": "Iterable",
          "isArray": false
        },
        "name": "doc"
      }
    ],
    "protocol": {
      "member": "addDocument(java.lang.Iterable<? extends org.apache.lucene.index.IndexableField> doc)",
      "comment": "Adds a document to this index.  Note that if an Exception is hit (for example disk full) then the index will be consistent, but this document may not have been added. Furthermore, it's possible the index will have one segment in non-compound format even when using compound files (when a merge has partially succeeded).  This method periodically flushes pending documents to the Directory (see <a href=\"#flush\">above</a>), and also periodically triggers segment merges in the index according to the MergePolicy in use. Merges temporarily consume space in the directory. The amount of space required is up to 1X the size of all segments being merged, when no readers/searchers are open against the index, and up to 2X the size of all segments being merged when readers/searchers are open against the index (see #method_0 for details). The sequence of primitive merge operations performed is governed by the merge policy. <p>Note that each term in the document can be no longer than #MAX_TERM_LENGTH in bytes, otherwise an IllegalArgumentException will be thrown. Note that it's possible to create an invalid Unicode string in java if a UTF16 surrogate pair is malformed. In this case, the invalid characters are silently replaced with the Unicode replacement character U+FFFD.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "addDocuments(java.lang.Iterable<? extends java.lang.Iterable<? extends org.apache.lucene.index.IndexableField>> docs)",
    "name": "addDocuments",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "long",
      "name": "long",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Iterable",
          "name": "Iterable",
          "isArray": false
        },
        "name": "docs"
      }
    ],
    "protocol": {
      "member": "addDocuments(java.lang.Iterable<? extends java.lang.Iterable<? extends org.apache.lucene.index.IndexableField>> docs)",
      "comment": "Atomically adds a block of documents with sequentially assigned document IDs, such that an external reader will see all or none of the documents. <b>WARNING</b>: the index does not currently record which documents were added as a block. Today this is fine, because merging will preserve a block. The order of documents within a segment will be preserved, even when child documents within a block are deleted. Most search features (like result grouping and block joining) require you to mark documents; when these documents are deleted these search features will not work as expected. Obviously adding documents to an existing block will require you the reindex the entire block. <p>However it's possible that in the future Lucene may merge more aggressively re-order documents (for example, perhaps to obtain better index compression), in which case you may need to fully re-index your documents at that time. <p>See #method_0 for details on index and IndexWriter state after an Exception, and flushing/merging temporary free space requirements. <p>NOTE: tools that do offline splitting of an index (for example, IndexSplitter in contrib) or re-sorting of documents (for example, IndexSorter in contrib) are not aware of these atomically added documents and will likely break them up. Use such tools at your own risk!",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "updateDocuments(org.apache.lucene.index.Term delTerm, java.lang.Iterable<? extends java.lang.Iterable<? extends org.apache.lucene.index.IndexableField>> docs)",
    "name": "updateDocuments",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "long",
      "name": "long",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "org.apache.lucene.index.Term",
          "name": "Term",
          "isArray": false
        },
        "name": "delTerm"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Iterable",
          "name": "Iterable",
          "isArray": false
        },
        "name": "docs"
      }
    ],
    "protocol": {
      "member": "updateDocuments(org.apache.lucene.index.Term delTerm, java.lang.Iterable<? extends java.lang.Iterable<? extends org.apache.lucene.index.IndexableField>> docs)",
      "comment": "Atomically deletes documents matching the provided delTerm and adds a block of documents with sequentially assigned document IDs, such that an external reader will see all or none of the documents. See #method_0",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "tryDeleteDocument(org.apache.lucene.index.IndexReader readerIn, int docID)",
    "name": "tryDeleteDocument",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "long",
      "name": "long",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "org.apache.lucene.index.IndexReader",
          "name": "IndexReader",
          "isArray": false
        },
        "name": "readerIn"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "docID"
      }
    ],
    "protocol": {
      "member": "tryDeleteDocument(org.apache.lucene.index.IndexReader readerIn, int docID)",
      "comment": "the provided reader is a near-real-time reader (from method_0 If the provided reader is an NRT reader obtained from this writer, and its segment has not been merged away, then the delete succeeds and this method returns a valid (> 0) sequence number; else, it returns -1 and the caller must then separately delete by Term or Query. NOTE: this method can only delete documents visible to the currently open NRT reader. If you need to delete documents indexed after opening the NRT reader you must use #deleteDocuments(Term...)).",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "dropDeletedSegment(org.apache.lucene.index.SegmentCommitInfo info)",
    "name": "dropDeletedSegment",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "org.apache.lucene.index.SegmentCommitInfo",
          "name": "SegmentCommitInfo",
          "isArray": false
        },
        "name": "info"
      }
    ],
    "protocol": {
      "member": "dropDeletedSegment(org.apache.lucene.index.SegmentCommitInfo info)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "deleteDocuments(org.apache.lucene.index.Term... terms)",
    "name": "deleteDocuments",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": true,
    "returnType": {
      "qualifiedName": "long",
      "name": "long",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Lorg.apache.lucene.index.Term;",
          "name": "Term[]",
          "isArray": true
        },
        "name": "terms"
      }
    ],
    "protocol": {
      "member": "deleteDocuments(org.apache.lucene.index.Term... terms)",
      "comment": "Deletes the method_0 containing any of the terms. All given deletes are applied and flushed atomically at the same time.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "deleteDocuments(org.apache.lucene.search.Query... queries)",
    "name": "deleteDocuments",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": true,
    "returnType": {
      "qualifiedName": "long",
      "name": "long",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Lorg.apache.lucene.search.Query;",
          "name": "Query[]",
          "isArray": true
        },
        "name": "queries"
      }
    ],
    "protocol": {
      "member": "deleteDocuments(org.apache.lucene.search.Query... queries)",
      "comment": "Deletes the method_0 matching any of the provided queries. All given deletes are applied and flushed atomically at the same time.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "updateDocument(org.apache.lucene.index.Term term, java.lang.Iterable<? extends org.apache.lucene.index.IndexableField> doc)",
    "name": "updateDocument",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "long",
      "name": "long",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "org.apache.lucene.index.Term",
          "name": "Term",
          "isArray": false
        },
        "name": "term"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Iterable",
          "name": "Iterable",
          "isArray": false
        },
        "name": "doc"
      }
    ],
    "protocol": {
      "member": "updateDocument(org.apache.lucene.index.Term term, java.lang.Iterable<? extends org.apache.lucene.index.IndexableField> doc)",
      "comment": "Updates a document by first deleting the method_0 containing term and then adding the new document. The delete and then add are atomic as seen by a reader on the same index (flush may happen only after the add).",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "updateNumericDocValue(org.apache.lucene.index.Term term, java.lang.String field, long value)",
    "name": "updateNumericDocValue",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "long",
      "name": "long",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "org.apache.lucene.index.Term",
          "name": "Term",
          "isArray": false
        },
        "name": "term"
      },
      {
        "type": {
          "qualifiedName": "java.lang.String",
          "name": "String",
          "isArray": false
        },
        "name": "field"
      },
      {
        "type": {
          "qualifiedName": "long",
          "name": "long",
          "isArray": false
        },
        "name": "value"
      }
    ],
    "protocol": {
      "member": "updateNumericDocValue(org.apache.lucene.index.Term term, java.lang.String field, long value)",
      "comment": "Updates a document's NumericDocValues for field to the given value. You can only update fields that already exist in the index, not add new fields through this method.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "updateBinaryDocValue(org.apache.lucene.index.Term term, java.lang.String field, org.apache.lucene.util.BytesRef value)",
    "name": "updateBinaryDocValue",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "long",
      "name": "long",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "org.apache.lucene.index.Term",
          "name": "Term",
          "isArray": false
        },
        "name": "term"
      },
      {
        "type": {
          "qualifiedName": "java.lang.String",
          "name": "String",
          "isArray": false
        },
        "name": "field"
      },
      {
        "type": {
          "qualifiedName": "org.apache.lucene.util.BytesRef",
          "name": "BytesRef",
          "isArray": false
        },
        "name": "value"
      }
    ],
    "protocol": {
      "member": "updateBinaryDocValue(org.apache.lucene.index.Term term, java.lang.String field, org.apache.lucene.util.BytesRef value)",
      "comment": "Updates a document's BinaryDocValues for field to the given value. You can only update fields that already exist in the index, not add new fields through this method.  NOTE: this method currently replaces the existing value of all affected documents with the new value.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "updateDocValues(org.apache.lucene.index.Term term, org.apache.lucene.document.Field... updates)",
    "name": "updateDocValues",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": true,
    "returnType": {
      "qualifiedName": "long",
      "name": "long",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "org.apache.lucene.index.Term",
          "name": "Term",
          "isArray": false
        },
        "name": "term"
      },
      {
        "type": {
          "qualifiedName": "[Lorg.apache.lucene.document.Field;",
          "name": "Field[]",
          "isArray": true
        },
        "name": "updates"
      }
    ],
    "protocol": {
      "member": "updateDocValues(org.apache.lucene.index.Term term, org.apache.lucene.document.Field... updates)",
      "comment": "Updates documents' DocValues fields to the given values. Each field update is applied to the set of documents that are associated with the Term to the same value. All updates are atomically applied and flushed together.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getSegmentCount()",
    "name": "getSegmentCount",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getSegmentCount()",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getNumBufferedDocuments()",
    "name": "getNumBufferedDocuments",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getNumBufferedDocuments()",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getIndexFileNames()",
    "name": "getIndexFileNames",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.Collection<java.lang.String>",
      "name": "java.util.Collection<java.lang.String>",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getIndexFileNames()",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "maxDoc(int i)",
    "name": "maxDoc",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "i"
      }
    ],
    "protocol": {
      "member": "maxDoc(int i)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getFlushCount()",
    "name": "getFlushCount",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getFlushCount()",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getFlushDeletesCount()",
    "name": "getFlushDeletesCount",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getFlushDeletesCount()",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getFieldNames()",
    "name": "getFieldNames",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.Set<java.lang.String>",
      "name": "java.util.Set<java.lang.String>",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getFieldNames()",
      "comment": "Return an unmodifiable set of all field names as visible from this IndexWriter, across all segments of the index. Useful for knowing which fields exist, before #method_0 is attempted. We could phase out this method if #method_0 could create the non-existent docValues fields as necessary, instead of throwing IllegalArgumentException for attempts to update non-existent docValues fields. @lucene.internal @lucene.experimental",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newSegmentName()",
    "name": "newSegmentName",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.lang.String",
      "name": "java.lang.String",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "newSegmentName()",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "forceMerge(int maxNumSegments)",
    "name": "forceMerge",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "maxNumSegments"
      }
    ],
    "protocol": {
      "member": "forceMerge(int maxNumSegments)",
      "comment": "Forces merge policy to merge segments until there are <= maxNumSegments. The actual merges to be executed are determined by the MergePolicy. This is a horribly costly operation, especially when you pass a small maxNumSegments; usually you should only call this if the index is static (will no longer be changed). Note that this requires free space that is proportional to the size of the index in your Directory: 2X if you are not using compound file format, and 3X if you are. For example, if your index size is 10 MB then you need an additional 20 MB free for this to complete (30 MB if you're using compound file format). This is also affected by the Codec that is used to execute the merge, and may result in even a bigger index. Also, it's best to call #method_0 afterwards, to allow IndexWriter to free up disk space. If some but not all readers re-open while merging is underway, this will cause > 2X temporary space to be consumed as those new readers will then hold open the temporary segments at that time. It is best not to re-open readers while merging is running. The actual temporary usage could be much less than these figures (it depends on many factors). In general, once this completes, the total size of the index will be less than the size of the starting index. It could be quite a bit smaller (if there were many pending deletes) or just slightly smaller. If an Exception is hit, for example due to disk full, the index will not be corrupted and no documents will be lost. However, it may have been partially merged (some segments were merged but not all), and it's possible that one of the segments in the index will be in non-compound format even when using compound file format. This will occur when the Exception is hit during conversion of the segment into compound format. This call will merge those segments present in the index when the call started. If other threads are still adding documents and flushing segments, those newly created segments will not be merged unless you call forceMerge again.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "forceMerge(int maxNumSegments, boolean doWait)",
    "name": "forceMerge",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "maxNumSegments"
      },
      {
        "type": {
          "qualifiedName": "boolean",
          "name": "boolean",
          "isArray": false
        },
        "name": "doWait"
      }
    ],
    "protocol": {
      "member": "forceMerge(int maxNumSegments, boolean doWait)",
      "comment": "specify whether the call should block until all merging completes. This is only meaningful with a MergeScheduler that is able to run merges in background threads.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "forceMergeDeletes(boolean doWait)",
    "name": "forceMergeDeletes",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "boolean",
          "name": "boolean",
          "isArray": false
        },
        "name": "doWait"
      }
    ],
    "protocol": {
      "member": "forceMergeDeletes(boolean doWait)",
      "comment": "specify whether the call should block until the operation completes. This is only meaningful with a MergeScheduler that is able to run merges in background threads.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "forceMergeDeletes()",
    "name": "forceMergeDeletes",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "forceMergeDeletes()",
      "comment": "Forces merging of all segments that have deleted documents. The actual merges to be executed are determined by the MergePolicy. For example, the default TieredMergePolicy will only pick a segment if the percentage of deleted docs is over 10%. This is often a horribly costly operation; rarely is it warranted. To see how many deletions you have pending in your index, call method_0. <p>NOTE: this method first flushes a new segment (if there are indexed documents), and applies all buffered deletes.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "maybeMerge()",
    "name": "maybeMerge",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "maybeMerge()",
      "comment": "Expert: asks the mergePolicy whether any merges are necessary now and if so, runs the requested merges and then iterate (test again if merges are needed) until no more merges are returned by the mergePolicy. Explicit calls to method_0 are usually not necessary. The most common case is when merge policy parameters have changed. This method will call the MergePolicy with MergeTrigger#EXPLICIT.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "maybeMerge(org.apache.lucene.index.MergePolicy mergePolicy, org.apache.lucene.index.MergeTrigger trigger, int maxNumSegments)",
    "name": "maybeMerge",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "org.apache.lucene.index.MergePolicy",
          "name": "MergePolicy",
          "isArray": false
        },
        "name": "mergePolicy"
      },
      {
        "type": {
          "qualifiedName": "org.apache.lucene.index.MergeTrigger",
          "name": "MergeTrigger",
          "isArray": false
        },
        "name": "trigger"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "maxNumSegments"
      }
    ],
    "protocol": {
      "member": "maybeMerge(org.apache.lucene.index.MergePolicy mergePolicy, org.apache.lucene.index.MergeTrigger trigger, int maxNumSegments)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getMergingSegments()",
    "name": "getMergingSegments",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.Set<org.apache.lucene.index.SegmentCommitInfo>",
      "name": "java.util.Set<org.apache.lucene.index.SegmentCommitInfo>",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getMergingSegments()",
      "comment": "selecting merges for segments already being merged. The returned collection is not cloned, and thus is only safe to access if you hold IndexWriter's lock (which you do when IndexWriter invokes the MergePolicy). The Set is unmodifiable.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getNextMerge()",
    "name": "getNextMerge",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "org.apache.lucene.index.MergePolicy$OneMerge",
      "name": "org.apache.lucene.index.MergePolicy$OneMerge",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getNextMerge()",
      "comment": "Expert: the MergeScheduler calls this method to retrieve the next merge requested by the MergePolicy @lucenemethod_0",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "hasPendingMerges()",
    "name": "hasPendingMerges",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "hasPendingMerges()",
      "comment": "Expert: returns true if there are merges waiting to be scheduled. @lucenemethod_0",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "rollback()",
    "name": "rollback",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "rollback()",
      "comment": "Close the IndexWriter without committing any changes that have occurred since the last commit (or since it was opened, if commit hasn't been called). This removes any temporary files that had been created, after which the state of the index will be the same as it was when method_0 was last called or when this writer was first opened. This also clears a previous call to #prepareCommit.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "deleteAll()",
    "name": "deleteAll",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "long",
      "name": "long",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "deleteAll()",
      "comment": "Delete all documents in the index.  This method will drop all buffered documents and will remove all segments from the index. This change will not be visible until a #method_0 has been called. This method can be rolled back using #rollback().   NOTE: this method is much faster than using deleteDocuments( new MatchAllDocsQuery() ). Yet, this method also has different semantics compared to #deleteDocuments(Query...) since internal data-structures are cleared as well as all segment information is forcefully dropped anti-viral semantics like omitting norms are reset or doc value types are cleared. Essentially a call to #deleteAll() is equivalent to creating a new IndexWriter with OpenMode#CREATE which a delete query only marks documents as deleted.  <p> NOTE: this method will forcefully abort all merges in progress. If other threads are running #forceMerge, #addIndexes(CodecReader[]) or #forceMergeDeletes methods, they may receive MergePolicy.MergeAbortedExceptions.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "waitForMerges()",
    "name": "waitForMerges",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "waitForMerges()",
      "comment": "Wait for any currently outstanding merges to finish. It is guaranteed that any merges started prior to calling this method will have completed once this method completes.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "checkpoint()",
    "name": "checkpoint",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "checkpoint()",
      "comment": "Called whenever the SegmentInfos has been updated and the index files referenced exist (correctly) in the index directory.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "checkpointNoSIS()",
    "name": "checkpointNoSIS",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "checkpointNoSIS()",
      "comment": "new files, and increments changeCount, so on close/commit we will write a new segments file, but does NOT bump segmentmethod_0.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "changed()",
    "name": "changed",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "changed()",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "publishFrozenUpdates(org.apache.lucene.index.FrozenBufferedUpdates packet)",
    "name": "publishFrozenUpdates",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "org.apache.lucene.index.FrozenBufferedUpdates",
          "name": "FrozenBufferedUpdates",
          "isArray": false
        },
        "name": "packet"
      }
    ],
    "protocol": {
      "member": "publishFrozenUpdates(org.apache.lucene.index.FrozenBufferedUpdates packet)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "publishFlushedSegment(org.apache.lucene.index.SegmentCommitInfo newSegment, org.apache.lucene.index.FrozenBufferedUpdates packet, org.apache.lucene.index.FrozenBufferedUpdates globalPacket, org.apache.lucene.index.Sorter$DocMap sortMap)",
    "name": "publishFlushedSegment",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "org.apache.lucene.index.SegmentCommitInfo",
          "name": "SegmentCommitInfo",
          "isArray": false
        },
        "name": "newSegment"
      },
      {
        "type": {
          "qualifiedName": "org.apache.lucene.index.FrozenBufferedUpdates",
          "name": "FrozenBufferedUpdates",
          "isArray": false
        },
        "name": "packet"
      },
      {
        "type": {
          "qualifiedName": "org.apache.lucene.index.FrozenBufferedUpdates",
          "name": "FrozenBufferedUpdates",
          "isArray": false
        },
        "name": "globalPacket"
      },
      {
        "type": {
          "qualifiedName": "org.apache.lucene.index.Sorter$DocMap",
          "name": "DocMap",
          "isArray": false
        },
        "name": "sortMap"
      }
    ],
    "protocol": {
      "member": "publishFlushedSegment(org.apache.lucene.index.SegmentCommitInfo newSegment, org.apache.lucene.index.FrozenBufferedUpdates packet, org.apache.lucene.index.FrozenBufferedUpdates globalPacket, org.apache.lucene.index.Sorter$DocMap sortMap)",
      "comment": "Atomically adds the segment private delete packet and publishes the flushed segments SegmentInfo to the index writer.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "addIndexes(org.apache.lucene.store.Directory... dirs)",
    "name": "addIndexes",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": true,
    "returnType": {
      "qualifiedName": "long",
      "name": "long",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Lorg.apache.lucene.store.Directory;",
          "name": "Directory[]",
          "isArray": true
        },
        "name": "dirs"
      }
    ],
    "protocol": {
      "member": "addIndexes(org.apache.lucene.store.Directory... dirs)",
      "comment": "Adds all segments from an array of indexes into this index. This may be used to parallelize batch indexing. A large document collection can be broken into sub-collections. Each sub-collection can be indexed in parallel, on a different thread, process or machine. The complete index can then be created by merging sub-collection indexes with this method.  NOTE: this method acquires the write lock in each directory, to ensure that no IndexWriter is currently open or tries to open while this is running. This method is transactional in how Exceptions are handled: it does not commit a new segments_N file until all indexes are added. This means if an Exception occurs (for example disk full), then either no indexes will have been added or they all will have been. Note that this requires temporary free space in the Directory up to 2X the sum of all input indexes (including the starting index). If readers/searchers are open against the starting index, then temporary free space required will be higher by the size of the starting index (see #method_0 for details). This requires this index not be among those to be added. All added indexes must have been created by the same Lucene version as this index.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "addIndexes(org.apache.lucene.index.CodecReader... readers)",
    "name": "addIndexes",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": true,
    "returnType": {
      "qualifiedName": "long",
      "name": "long",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Lorg.apache.lucene.index.CodecReader;",
          "name": "CodecReader[]",
          "isArray": true
        },
        "name": "readers"
      }
    ],
    "protocol": {
      "member": "addIndexes(org.apache.lucene.index.CodecReader... readers)",
      "comment": "Merges the provided indexes into this index.  The provided IndexReaders are not closed.  See method_0 for details on transactional semantics, temporary free space required in the Directory, and non-CFS segments on an Exception.  NOTE: empty segments are dropped by this method and not added to this index.  NOTE: this merges all given LeafReaders in one merge. If you intend to merge a large number of readers, it may be better to call this method multiple times, each time with a small set of readers. In principle, if you use a merge policy with a mergeFactor or maxMergeAtOnce parameter, you should pass that many readers in one call.  NOTE: this method does not call or make use of the MergeScheduler, so any custom bandwidth throttling is at the moment ignored.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "doAfterFlush()",
    "name": "doAfterFlush",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "doAfterFlush()",
      "comment": "A hook for extending classes to execute operations after pending added and deleted documents have been flushed to the Directory but before the change is committed (new segments_N file written).",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "doBeforeFlush()",
    "name": "doBeforeFlush",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "doBeforeFlush()",
      "comment": "A hook for extending classes to execute operations before pending added and deleted documents are flushed to the Directory.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "prepareCommit()",
    "name": "prepareCommit",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "long",
      "name": "long",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "prepareCommit()",
      "comment": "first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either #method_0 to finish the commit, or #rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call #method_0 directly without prepareCommit first in which case that method will internally call prepareCommit.",
      "kind": "FreeText",
      "condition": "org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()"
    }
  },
  {
    "signature": "flushNextBuffer()",
    "name": "flushNextBuffer",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "flushNextBuffer()",
      "comment": "Expert: Flushes the next pending writer per thread buffer if available or the largest active non-pending writer per thread buffer in the calling thread. This can be used to flush documents to disk outside of an indexing thread. In contrast to #method_0 this won't mark all currently active indexing buffers as flush-pending. Note: this method is best-effort and might not flush any segments to disk. If there is a full flush happening concurrently multiple segments might have been flushed. Users of this API can access the IndexWriters current memory consumption via #ramBytesUsed()",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "setLiveCommitData(java.lang.Iterable<java.util.Map$Entry<java.lang.String, java.lang.String>> commitUserData)",
    "name": "setLiveCommitData",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Iterable",
          "name": "Iterable",
          "isArray": false
        },
        "name": "commitUserData"
      }
    ],
    "protocol": {
      "member": "setLiveCommitData(java.lang.Iterable<java.util.Map$Entry<java.lang.String, java.lang.String>> commitUserData)",
      "comment": "Sets the iterator to provide the commit user data map at commit time. Calling this method is considered a committable change and will be #method_0 committed even if there are no other changes this writer. Note that you must call this method before #prepareCommit(). Otherwise it won't be included in the follow-on #method_0.  NOTE: the iterator is late-binding: it is only visited once all documents for the commit have been written to their segments, before the next segments_N file is written",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "setLiveCommitData(java.lang.Iterable<java.util.Map$Entry<java.lang.String, java.lang.String>> commitUserData, boolean doIncrementVersion)",
    "name": "setLiveCommitData",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Iterable",
          "name": "Iterable",
          "isArray": false
        },
        "name": "commitUserData"
      },
      {
        "type": {
          "qualifiedName": "boolean",
          "name": "boolean",
          "isArray": false
        },
        "name": "doIncrementVersion"
      }
    ],
    "protocol": {
      "member": "setLiveCommitData(java.lang.Iterable<java.util.Map$Entry<java.lang.String, java.lang.String>> commitUserData, boolean doIncrementVersion)",
      "comment": "Sets the commit user data iterator, controlling whether to advance the method_0.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getLiveCommitData()",
    "name": "getLiveCommitData",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.lang.Iterable<java.util.Map$Entry<java.lang.String, java.lang.String>>",
      "name": "java.lang.Iterable<java.util.Map$Entry<java.lang.String, java.lang.String>>",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getLiveCommitData()",
      "comment": "Returns the commit user data iterable previously set with #method_0, or null if nothing has been set yet.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "commit()",
    "name": "commit",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "long",
      "name": "long",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "commit()",
      "comment": "Commits all pending changes (added and deleted documents, segment merges, added indexes, etc.) to the index, and syncs all referenced index files, such that a reader will see the changes and the index updates will survive an OS or machine crash or power loss. Note that this does not wait for any running background merges to finish. This may be a costly operation, so you should test the cost in your application and do it only when really necessary.  Note that this operation calls method_0 on the index files. That call should not return until the file contents and metadata are on stable storage. For FSDirectory, this calls the OS's fsync. But, beware: some hardware devices may in fact cache writes even during fsync, and return before the bits are actually on stable storage, to give the appearance of faster performance. If you have such a device, and it does not have a battery backup (for example) then on power loss it may still lose data. Lucene cannot guarantee consistency on such devices.   If nothing was committed, because there were no pending changes, this returns -1. Otherwise, it returns the sequence number such that all indexing operations prior to this sequence will be included in the commit point, and all other operations will not.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "hasUncommittedChanges()",
    "name": "hasUncommittedChanges",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "hasUncommittedChanges()",
      "comment": "committed. There are cases where this may return true when there are no actual \"real\" changes to the index, for example if you've deleted by Term or Query but that Term or Query does not match any documents. Also, if a merge kicked off as a result of flushing a new segment during method_0, or a concurrent merged finished, this method may return true right after you had just called method_0.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "holdsFullFlushLock()",
    "name": "holdsFullFlushLock",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "holdsFullFlushLock()",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "flush()",
    "name": "flush",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "flush()",
      "comment": "(fsync) them (call method_0 for that).",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "flush(boolean triggerMerge, boolean applyAllDeletes)",
    "name": "flush",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "boolean",
          "name": "boolean",
          "isArray": false
        },
        "name": "triggerMerge"
      },
      {
        "type": {
          "qualifiedName": "boolean",
          "name": "boolean",
          "isArray": false
        },
        "name": "applyAllDeletes"
      }
    ],
    "protocol": {
      "member": "flush(boolean triggerMerge, boolean applyAllDeletes)",
      "comment": "Flush all in-memory buffered updates (adds and deletes) to the Directory.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "applyAllDeletesAndUpdates()",
    "name": "applyAllDeletesAndUpdates",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "applyAllDeletesAndUpdates()",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getDocsWriter()",
    "name": "getDocsWriter",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "org.apache.lucene.index.DocumentsWriter",
      "name": "org.apache.lucene.index.DocumentsWriter",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getDocsWriter()",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "numRamDocs()",
    "name": "numRamDocs",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "numRamDocs()",
      "comment": "buffered in RAM.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "merge(org.apache.lucene.index.MergePolicy$OneMerge merge)",
    "name": "merge",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "org.apache.lucene.index.MergePolicy$OneMerge",
          "name": "OneMerge",
          "isArray": false
        },
        "name": "merge"
      }
    ],
    "protocol": {
      "member": "merge(org.apache.lucene.index.MergePolicy$OneMerge merge)",
      "comment": "Merges the indicated segments, replacing them in the stack with a single segment. @lucenemethod_0",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "mergeSuccess(org.apache.lucene.index.MergePolicy$OneMerge merge)",
    "name": "mergeSuccess",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "org.apache.lucene.index.MergePolicy$OneMerge",
          "name": "OneMerge",
          "isArray": false
        },
        "name": "merge"
      }
    ],
    "protocol": {
      "member": "mergeSuccess(org.apache.lucene.index.MergePolicy$OneMerge merge)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "registerMerge(org.apache.lucene.index.MergePolicy$OneMerge merge)",
    "name": "registerMerge",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "org.apache.lucene.index.MergePolicy$OneMerge",
          "name": "OneMerge",
          "isArray": false
        },
        "name": "merge"
      }
    ],
    "protocol": {
      "member": "registerMerge(org.apache.lucene.index.MergePolicy$OneMerge merge)",
      "comment": "already participating in a merge. If not, this merge is \"registered\", meaning we record that its segments are now participating in a merge, and true is returned. Else (the merge conflicts) false is returned.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "mergeInit(org.apache.lucene.index.MergePolicy$OneMerge merge)",
    "name": "mergeInit",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "org.apache.lucene.index.MergePolicy$OneMerge",
          "name": "OneMerge",
          "isArray": false
        },
        "name": "merge"
      }
    ],
    "protocol": {
      "member": "mergeInit(org.apache.lucene.index.MergePolicy$OneMerge merge)",
      "comment": "the synchronized lock on IndexWriter instance.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "setDiagnostics(org.apache.lucene.index.SegmentInfo info, java.lang.String source)",
    "name": "setDiagnostics",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "org.apache.lucene.index.SegmentInfo",
          "name": "SegmentInfo",
          "isArray": false
        },
        "name": "info"
      },
      {
        "type": {
          "qualifiedName": "java.lang.String",
          "name": "String",
          "isArray": false
        },
        "name": "source"
      }
    ],
    "protocol": {
      "member": "setDiagnostics(org.apache.lucene.index.SegmentInfo info, java.lang.String source)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "mergeFinish(org.apache.lucene.index.MergePolicy$OneMerge merge)",
    "name": "mergeFinish",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "org.apache.lucene.index.MergePolicy$OneMerge",
          "name": "OneMerge",
          "isArray": false
        },
        "name": "merge"
      }
    ],
    "protocol": {
      "member": "mergeFinish(org.apache.lucene.index.MergePolicy$OneMerge merge)",
      "comment": "the synchronized lock on IndexWriter instance.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "addMergeException(org.apache.lucene.index.MergePolicy$OneMerge merge)",
    "name": "addMergeException",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "org.apache.lucene.index.MergePolicy$OneMerge",
          "name": "OneMerge",
          "isArray": false
        },
        "name": "merge"
      }
    ],
    "protocol": {
      "member": "addMergeException(org.apache.lucene.index.MergePolicy$OneMerge merge)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getBufferedDeleteTermsSize()",
    "name": "getBufferedDeleteTermsSize",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getBufferedDeleteTermsSize()",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getNumBufferedDeleteTerms()",
    "name": "getNumBufferedDeleteTerms",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getNumBufferedDeleteTerms()",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newestSegment()",
    "name": "newestSegment",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "org.apache.lucene.index.SegmentCommitInfo",
      "name": "org.apache.lucene.index.SegmentCommitInfo",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "newestSegment()",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "segString()",
    "name": "segString",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.lang.String",
      "name": "java.lang.String",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "segString()",
      "comment": "debugging. @lucenemethod_0",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "segString(java.lang.Iterable<org.apache.lucene.index.SegmentCommitInfo> infos)",
    "name": "segString",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.lang.String",
      "name": "java.lang.String",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Iterable",
          "name": "Iterable",
          "isArray": false
        },
        "name": "infos"
      }
    ],
    "protocol": {
      "member": "segString(java.lang.Iterable<org.apache.lucene.index.SegmentCommitInfo> infos)",
      "comment": "segments, for debugging. @lucenemethod_0",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "segString(org.apache.lucene.index.SegmentCommitInfo info)",
    "name": "segString",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.lang.String",
      "name": "java.lang.String",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "org.apache.lucene.index.SegmentCommitInfo",
          "name": "SegmentCommitInfo",
          "isArray": false
        },
        "name": "info"
      }
    ],
    "protocol": {
      "member": "segString(org.apache.lucene.index.SegmentCommitInfo info)",
      "comment": "segment, for debugging. @lucenemethod_0",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "setKeepFullyDeletedSegments(boolean v)",
    "name": "setKeepFullyDeletedSegments",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "boolean",
          "name": "boolean",
          "isArray": false
        },
        "name": "v"
      }
    ],
    "protocol": {
      "member": "setKeepFullyDeletedSegments(boolean v)",
      "comment": "@lucenemethod_0",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getKeepFullyDeletedSegments()",
    "name": "getKeepFullyDeletedSegments",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getKeepFullyDeletedSegments()",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "toLiveInfos(org.apache.lucene.index.SegmentInfos sis)",
    "name": "toLiveInfos",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "org.apache.lucene.index.SegmentInfos",
      "name": "org.apache.lucene.index.SegmentInfos",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "org.apache.lucene.index.SegmentInfos",
          "name": "SegmentInfos",
          "isArray": false
        },
        "name": "sis"
      }
    ],
    "protocol": {
      "member": "toLiveInfos(org.apache.lucene.index.SegmentInfos sis)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "tragicEvent(java.lang.Throwable tragedy, java.lang.String location)",
    "name": "tragicEvent",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Throwable",
          "name": "Throwable",
          "isArray": false
        },
        "name": "tragedy"
      },
      {
        "type": {
          "qualifiedName": "java.lang.String",
          "name": "String",
          "isArray": false
        },
        "name": "location"
      }
    ],
    "protocol": {
      "member": "tragicEvent(java.lang.Throwable tragedy, java.lang.String location)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getTragicException()",
    "name": "getTragicException",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.lang.Throwable",
      "name": "java.lang.Throwable",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getTragicException()",
      "comment": "emethod_0. disk full while flushing a new segment, this returns the root cause exception. Otherwise (no tragic exception has occurred) it returns null.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "isOpen()",
    "name": "isOpen",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "isOpen()",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "nrtIsCurrent(org.apache.lucene.index.SegmentInfos infos)",
    "name": "nrtIsCurrent",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "org.apache.lucene.index.SegmentInfos",
          "name": "SegmentInfos",
          "isArray": false
        },
        "name": "infos"
      }
    ],
    "protocol": {
      "member": "nrtIsCurrent(org.apache.lucene.index.SegmentInfos infos)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "isClosed()",
    "name": "isClosed",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "isClosed()",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "deleteUnusedFiles()",
    "name": "deleteUnusedFiles",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "deleteUnusedFiles()",
      "comment": "used.  IndexWriter normally deletes unused files itself, during indexing. However, on Windows, which disallows deletion of open files, if there is a reader open on the index then those files cannot be deleted. This is fine, because IndexWriter will periodically retry the deletion. <p> However, IndexWriter doesn't try that often: only on open, close, flushing a new segment, and finishing a merge. If you don't do any of these actions with your IndexWriter, you'll see the unused files linger. If that's a problem, call this method to delete them (once you've closed the open readers that were preventing their deletion). <p> In addition, you can call this method to delete unreferenced index commits. This might be useful if you are using an IndexDeletionPolicy which holds onto index commits until some criteria are met, but those commits are no longer needed. Otherwise, those commits will be deleted the next time method_0 is called.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "createCompoundFile(org.apache.lucene.util.InfoStream infoStream, org.apache.lucene.store.TrackingDirectoryWrapper directory, org.apache.lucene.index.SegmentInfo info, org.apache.lucene.store.IOContext context)",
    "name": "createCompoundFile",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "org.apache.lucene.util.InfoStream",
          "name": "InfoStream",
          "isArray": false
        },
        "name": "infoStream"
      },
      {
        "type": {
          "qualifiedName": "org.apache.lucene.store.TrackingDirectoryWrapper",
          "name": "TrackingDirectoryWrapper",
          "isArray": false
        },
        "name": "directory"
      },
      {
        "type": {
          "qualifiedName": "org.apache.lucene.index.SegmentInfo",
          "name": "SegmentInfo",
          "isArray": false
        },
        "name": "info"
      },
      {
        "type": {
          "qualifiedName": "org.apache.lucene.store.IOContext",
          "name": "IOContext",
          "isArray": false
        },
        "name": "context"
      }
    ],
    "protocol": {
      "member": "createCompoundFile(org.apache.lucene.util.InfoStream infoStream, org.apache.lucene.store.TrackingDirectoryWrapper directory, org.apache.lucene.index.SegmentInfo info, org.apache.lucene.store.IOContext context)",
      "comment": "NOTE: this method creates a compound file for all files returned by method_0 While, generally, this may include separate norms and deletion files, this SegmentInfo must not reference such files when this method is called, because they are not allowed within a compound file.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "deleteNewFiles(java.util.Collection<java.lang.String> files)",
    "name": "deleteNewFiles",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Collection",
          "name": "Collection",
          "isArray": false
        },
        "name": "files"
      }
    ],
    "protocol": {
      "member": "deleteNewFiles(java.util.Collection<java.lang.String> files)",
      "comment": "Tries to delete the given files if unreferenced",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "flushFailed(org.apache.lucene.index.SegmentInfo info)",
    "name": "flushFailed",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "org.apache.lucene.index.SegmentInfo",
          "name": "SegmentInfo",
          "isArray": false
        },
        "name": "info"
      }
    ],
    "protocol": {
      "member": "flushFailed(org.apache.lucene.index.SegmentInfo info)",
      "comment": "Cleans up residuals from a segment that could not be entirely flushed due to an error",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "purge(boolean forced)",
    "name": "purge",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "boolean",
          "name": "boolean",
          "isArray": false
        },
        "name": "forced"
      }
    ],
    "protocol": {
      "member": "purge(boolean forced)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "applyDeletesAndPurge(boolean forcePurge)",
    "name": "applyDeletesAndPurge",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "boolean",
          "name": "boolean",
          "isArray": false
        },
        "name": "forcePurge"
      }
    ],
    "protocol": {
      "member": "applyDeletesAndPurge(boolean forcePurge)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "doAfterSegmentFlushed(boolean triggerMerge, boolean forcePurge)",
    "name": "doAfterSegmentFlushed",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "boolean",
          "name": "boolean",
          "isArray": false
        },
        "name": "triggerMerge"
      },
      {
        "type": {
          "qualifiedName": "boolean",
          "name": "boolean",
          "isArray": false
        },
        "name": "forcePurge"
      }
    ],
    "protocol": {
      "member": "doAfterSegmentFlushed(boolean triggerMerge, boolean forcePurge)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "incRefDeleter(org.apache.lucene.index.SegmentInfos segmentInfos)",
    "name": "incRefDeleter",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "org.apache.lucene.index.SegmentInfos",
          "name": "SegmentInfos",
          "isArray": false
        },
        "name": "segmentInfos"
      }
    ],
    "protocol": {
      "member": "incRefDeleter(org.apache.lucene.index.SegmentInfos segmentInfos)",
      "comment": "@lucenemethod_0",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "decRefDeleter(org.apache.lucene.index.SegmentInfos segmentInfos)",
    "name": "decRefDeleter",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "org.apache.lucene.index.SegmentInfos",
          "name": "SegmentInfos",
          "isArray": false
        },
        "name": "segmentInfos"
      }
    ],
    "protocol": {
      "member": "decRefDeleter(org.apache.lucene.index.SegmentInfos segmentInfos)",
      "comment": "called method_0. @lucene.internal",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getMaxCompletedSequenceNumber()",
    "name": "getMaxCompletedSequenceNumber",
    "containingClass": {
      "qualifiedName": "org.apache.lucene.index.IndexWriter",
      "name": "IndexWriter",
      "isArray": false
    },
    "targetClass": "org.apache.lucene.index.IndexWriter",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "long",
      "name": "long",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getMaxCompletedSequenceNumber()",
      "comment": "all completed operations, or 0 if no operations have finished yet. Still in-flight operations (in other threads) are not counted until they finish. @lucenemethod_0",
      "kind": "FreeText",
      "condition": ""
    }
  }
]