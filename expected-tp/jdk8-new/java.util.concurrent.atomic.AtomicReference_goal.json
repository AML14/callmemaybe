[
  {
    "signature": "java.util.concurrent.atomic.AtomicReference(V initialValue)",
    "name": "java.util.concurrent.atomic.AtomicReference",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.atomic.AtomicReference",
      "name": "AtomicReference",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.atomic.AtomicReference",
    "isVarArgs": false,
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "initialValue"
      }
    ],
    "protocol": {
      "member": "java.util.concurrent.atomic.AtomicReference(V initialValue)",
      "comment": "Creates a new AtomicReference with the given initial value.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "java.util.concurrent.atomic.AtomicReference()",
    "name": "java.util.concurrent.atomic.AtomicReference",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.atomic.AtomicReference",
      "name": "AtomicReference",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.atomic.AtomicReference",
    "isVarArgs": false,
    "parameters": [],
    "protocol": {
      "member": "java.util.concurrent.atomic.AtomicReference()",
      "comment": "Creates a new AtomicReference with null initial value.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "get()",
    "name": "get",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.atomic.AtomicReference",
      "name": "AtomicReference",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.atomic.AtomicReference",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "V",
      "name": "V",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "get()",
      "comment": "Gets the current value.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "set(V newValue)",
    "name": "set",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.atomic.AtomicReference",
      "name": "AtomicReference",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.atomic.AtomicReference",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "newValue"
      }
    ],
    "protocol": {
      "member": "set(V newValue)",
      "comment": "Sets to the given value.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "lazySet(V newValue)",
    "name": "lazySet",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.atomic.AtomicReference",
      "name": "AtomicReference",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.atomic.AtomicReference",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "newValue"
      }
    ],
    "protocol": {
      "member": "lazySet(V newValue)",
      "comment": "Eventually sets to the given value.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "compareAndSet(V expect, V update)",
    "name": "compareAndSet",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.atomic.AtomicReference",
      "name": "AtomicReference",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.atomic.AtomicReference",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "expect"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "update"
      }
    ],
    "protocol": {
      "member": "compareAndSet(V expect, V update)",
      "comment": "Atomically sets the value to the given updated value if the current value == the expected value.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "weakCompareAndSet(V expect, V update)",
    "name": "weakCompareAndSet",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.atomic.AtomicReference",
      "name": "AtomicReference",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.atomic.AtomicReference",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "expect"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "update"
      }
    ],
    "protocol": {
      "member": "weakCompareAndSet(V expect, V update)",
      "comment": "Atomically sets the value to the given updated value if the current value == the expected value. May fail spuriously and does not provide ordering guarantees, so is only rarely an appropriate alternative to compareAndSet.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getAndSet(V newValue)",
    "name": "getAndSet",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.atomic.AtomicReference",
      "name": "AtomicReference",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.atomic.AtomicReference",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "V",
      "name": "V",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "newValue"
      }
    ],
    "protocol": {
      "member": "getAndSet(V newValue)",
      "comment": "Atomically sets to the given value and returns the old value.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getAndUpdate(java.util.function.UnaryOperator<V> updateFunction)",
    "name": "getAndUpdate",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.atomic.AtomicReference",
      "name": "AtomicReference",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.atomic.AtomicReference",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "V",
      "name": "V",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.function.UnaryOperator",
          "name": "UnaryOperator",
          "isArray": false
        },
        "name": "updateFunction"
      }
    ],
    "protocol": {
      "member": "getAndUpdate(java.util.function.UnaryOperator<V> updateFunction)",
      "comment": "Atomically updates the current value with the results of applying the given function, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "updateAndGet(java.util.function.UnaryOperator<V> updateFunction)",
    "name": "updateAndGet",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.atomic.AtomicReference",
      "name": "AtomicReference",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.atomic.AtomicReference",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "V",
      "name": "V",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.function.UnaryOperator",
          "name": "UnaryOperator",
          "isArray": false
        },
        "name": "updateFunction"
      }
    ],
    "protocol": {
      "member": "updateAndGet(java.util.function.UnaryOperator<V> updateFunction)",
      "comment": "Atomically updates the current value with the results of applying the given function, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getAndAccumulate(V x, java.util.function.BinaryOperator<V> accumulatorFunction)",
    "name": "getAndAccumulate",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.atomic.AtomicReference",
      "name": "AtomicReference",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.atomic.AtomicReference",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "V",
      "name": "V",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "x"
      },
      {
        "type": {
          "qualifiedName": "java.util.function.BinaryOperator",
          "name": "BinaryOperator",
          "isArray": false
        },
        "name": "accumulatorFunction"
      }
    ],
    "protocol": {
      "member": "getAndAccumulate(V x, java.util.function.BinaryOperator<V> accumulatorFunction)",
      "comment": "Atomically updates the current value with the results of applying the given function to the current and given values, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads. The function is applied with the current value as its first argument, and the given update as the second argument.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "accumulateAndGet(V x, java.util.function.BinaryOperator<V> accumulatorFunction)",
    "name": "accumulateAndGet",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.atomic.AtomicReference",
      "name": "AtomicReference",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.atomic.AtomicReference",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "V",
      "name": "V",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "x"
      },
      {
        "type": {
          "qualifiedName": "java.util.function.BinaryOperator",
          "name": "BinaryOperator",
          "isArray": false
        },
        "name": "accumulatorFunction"
      }
    ],
    "protocol": {
      "member": "accumulateAndGet(V x, java.util.function.BinaryOperator<V> accumulatorFunction)",
      "comment": "Atomically updates the current value with the results of applying the given function to the current and given values, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads. The function is applied with the current value as its first argument, and the given update as the second argument.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "toString()",
    "name": "toString",
    "containingClass": {
      "qualifiedName": "java.util.concurrent.atomic.AtomicReference",
      "name": "AtomicReference",
      "isArray": false
    },
    "targetClass": "java.util.concurrent.atomic.AtomicReference",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.lang.String",
      "name": "java.lang.String",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "toString()",
      "comment": "Returns the String representation of the current value.",
      "kind": "FreeText",
      "condition": ""
    }
  }
]