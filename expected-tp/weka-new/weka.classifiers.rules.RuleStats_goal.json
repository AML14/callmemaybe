[
  {
    "signature": "weka.classifiers.rules.RuleStats()",
    "name": "weka.classifiers.rules.RuleStats",
    "containingClass": {
      "qualifiedName": "weka.classifiers.rules.RuleStats",
      "name": "RuleStats",
      "isArray": false
    },
    "targetClass": "weka.classifiers.rules.RuleStats",
    "isVarArgs": false,
    "parameters": [],
    "protocol": {
      "member": "weka.classifiers.rules.RuleStats()",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "weka.classifiers.rules.RuleStats(weka.core.Instances data, java.util.ArrayList<weka.classifiers.rules.Rule> rules)",
    "name": "weka.classifiers.rules.RuleStats",
    "containingClass": {
      "qualifiedName": "weka.classifiers.rules.RuleStats",
      "name": "RuleStats",
      "isArray": false
    },
    "targetClass": "weka.classifiers.rules.RuleStats",
    "isVarArgs": false,
    "parameters": [
      {
        "type": {
          "qualifiedName": "weka.core.Instances",
          "name": "Instances",
          "isArray": false
        },
        "name": "data"
      },
      {
        "type": {
          "qualifiedName": "java.util.ArrayList",
          "name": "ArrayList",
          "isArray": false
        },
        "name": "rules"
      }
    ],
    "protocol": {
      "member": "weka.classifiers.rules.RuleStats(weka.core.Instances data, java.util.ArrayList<weka.classifiers.rules.Rule> rules)",
      "comment": "Constructor that provides ruleset and data",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "cleanUp()",
    "name": "cleanUp",
    "containingClass": {
      "qualifiedName": "weka.classifiers.rules.RuleStats",
      "name": "RuleStats",
      "isArray": false
    },
    "targetClass": "weka.classifiers.rules.RuleStats",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "cleanUp()",
      "comment": "Frees up memory after classifier has been built.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "setNumAllConds(double total)",
    "name": "setNumAllConds",
    "containingClass": {
      "qualifiedName": "weka.classifiers.rules.RuleStats",
      "name": "RuleStats",
      "isArray": false
    },
    "targetClass": "weka.classifiers.rules.RuleStats",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "total"
      }
    ],
    "protocol": {
      "member": "setNumAllConds(double total)",
      "comment": "Set the number of all conditions that could appear in a rule in this RuleStats object, if the number set is smaller than 0 (typically -1), then it calcualtes based on the data store",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "setData(weka.core.Instances data)",
    "name": "setData",
    "containingClass": {
      "qualifiedName": "weka.classifiers.rules.RuleStats",
      "name": "RuleStats",
      "isArray": false
    },
    "targetClass": "weka.classifiers.rules.RuleStats",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "weka.core.Instances",
          "name": "Instances",
          "isArray": false
        },
        "name": "data"
      }
    ],
    "protocol": {
      "member": "setData(weka.core.Instances data)",
      "comment": "Set the data of the stats, overwriting the old one if any",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getData()",
    "name": "getData",
    "containingClass": {
      "qualifiedName": "weka.classifiers.rules.RuleStats",
      "name": "RuleStats",
      "isArray": false
    },
    "targetClass": "weka.classifiers.rules.RuleStats",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "weka.core.Instances",
      "name": "weka.core.Instances",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getData()",
      "comment": "Get the data of the stats",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "setRuleset(java.util.ArrayList<weka.classifiers.rules.Rule> rules)",
    "name": "setRuleset",
    "containingClass": {
      "qualifiedName": "weka.classifiers.rules.RuleStats",
      "name": "RuleStats",
      "isArray": false
    },
    "targetClass": "weka.classifiers.rules.RuleStats",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.ArrayList",
          "name": "ArrayList",
          "isArray": false
        },
        "name": "rules"
      }
    ],
    "protocol": {
      "member": "setRuleset(java.util.ArrayList<weka.classifiers.rules.Rule> rules)",
      "comment": "Set the ruleset of the stats, overwriting the old one if any",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getRuleset()",
    "name": "getRuleset",
    "containingClass": {
      "qualifiedName": "weka.classifiers.rules.RuleStats",
      "name": "RuleStats",
      "isArray": false
    },
    "targetClass": "weka.classifiers.rules.RuleStats",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.ArrayList<weka.classifiers.rules.Rule>",
      "name": "java.util.ArrayList<weka.classifiers.rules.Rule>",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getRuleset()",
      "comment": "Get the ruleset of the stats",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getRulesetSize()",
    "name": "getRulesetSize",
    "containingClass": {
      "qualifiedName": "weka.classifiers.rules.RuleStats",
      "name": "RuleStats",
      "isArray": false
    },
    "targetClass": "weka.classifiers.rules.RuleStats",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getRulesetSize()",
      "comment": "Get the size of the ruleset in the stats",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getSimpleStats(int index)",
    "name": "getSimpleStats",
    "containingClass": {
      "qualifiedName": "weka.classifiers.rules.RuleStats",
      "name": "RuleStats",
      "isArray": false
    },
    "targetClass": "weka.classifiers.rules.RuleStats",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "double[]",
      "name": "double[]",
      "isArray": true
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "index"
      }
    ],
    "protocol": {
      "member": "getSimpleStats(int index)",
      "comment": "Get the simple stats of one rule, including 6 parameters: 0: coverage; 1:uncoverage; 2: true positive; 3: true negatives; 4: false positives; 5: false negatives",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getFiltered(int index)",
    "name": "getFiltered",
    "containingClass": {
      "qualifiedName": "weka.classifiers.rules.RuleStats",
      "name": "RuleStats",
      "isArray": false
    },
    "targetClass": "weka.classifiers.rules.RuleStats",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "weka.core.Instances[]",
      "name": "weka.core.Instances[]",
      "isArray": true
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "index"
      }
    ],
    "protocol": {
      "member": "getFiltered(int index)",
      "comment": "Get the data after filtering the given rule",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getDistributions(int index)",
    "name": "getDistributions",
    "containingClass": {
      "qualifiedName": "weka.classifiers.rules.RuleStats",
      "name": "RuleStats",
      "isArray": false
    },
    "targetClass": "weka.classifiers.rules.RuleStats",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "double[]",
      "name": "double[]",
      "isArray": true
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "index"
      }
    ],
    "protocol": {
      "member": "getDistributions(int index)",
      "comment": "Get the class distribution predicted by the rule in given position",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "setMDLTheoryWeight(double weight)",
    "name": "setMDLTheoryWeight",
    "containingClass": {
      "qualifiedName": "weka.classifiers.rules.RuleStats",
      "name": "RuleStats",
      "isArray": false
    },
    "targetClass": "weka.classifiers.rules.RuleStats",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "weight"
      }
    ],
    "protocol": {
      "member": "setMDLTheoryWeight(double weight)",
      "comment": "Set the weight of theory in MDL calcualtion",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "numAllConditions(weka.core.Instances data)",
    "name": "numAllConditions",
    "containingClass": {
      "qualifiedName": "weka.classifiers.rules.RuleStats",
      "name": "RuleStats",
      "isArray": false
    },
    "targetClass": "weka.classifiers.rules.RuleStats",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "double",
      "name": "double",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "weka.core.Instances",
          "name": "Instances",
          "isArray": false
        },
        "name": "data"
      }
    ],
    "protocol": {
      "member": "numAllConditions(weka.core.Instances data)",
      "comment": "Compute the number of all possible conditions that could appear in a rule of a given data. For nominal attributes, it's the number of values that could appear; for numeric attributes, it's the number of values * 2, imethod_0. <= and >= are counted as different possible conditions.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "countData()",
    "name": "countData",
    "containingClass": {
      "qualifiedName": "weka.classifiers.rules.RuleStats",
      "name": "RuleStats",
      "isArray": false
    },
    "targetClass": "weka.classifiers.rules.RuleStats",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "countData()",
      "comment": "Filter the data according to the ruleset and compute the basic stats: coverage/uncoverage, true/false positive/negatives of each rule",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "countData(int index, weka.core.Instances uncovered, double[][] prevRuleStats)",
    "name": "countData",
    "containingClass": {
      "qualifiedName": "weka.classifiers.rules.RuleStats",
      "name": "RuleStats",
      "isArray": false
    },
    "targetClass": "weka.classifiers.rules.RuleStats",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "index"
      },
      {
        "type": {
          "qualifiedName": "weka.core.Instances",
          "name": "Instances",
          "isArray": false
        },
        "name": "uncovered"
      },
      {
        "type": {
          "qualifiedName": "[[D",
          "name": "double[][]",
          "isArray": true
        },
        "name": "prevRuleStats"
      }
    ],
    "protocol": {
      "member": "countData(int index, weka.core.Instances uncovered, double[][] prevRuleStats)",
      "comment": "Count data from the position index in the ruleset assuming that given data are not covered by the rules in position 0...(index-1), and the statistics of these rules are provided.<br> This procedure is typically useful when a temporary object of RuleStats is constructed in order to efficiently calculate the relative DL of rule in position index, thus all other stuff is not needed.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "addAndUpdate(weka.classifiers.rules.Rule lastRule)",
    "name": "addAndUpdate",
    "containingClass": {
      "qualifiedName": "weka.classifiers.rules.RuleStats",
      "name": "RuleStats",
      "isArray": false
    },
    "targetClass": "weka.classifiers.rules.RuleStats",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "weka.classifiers.rules.Rule",
          "name": "Rule",
          "isArray": false
        },
        "name": "lastRule"
      }
    ],
    "protocol": {
      "member": "addAndUpdate(weka.classifiers.rules.Rule lastRule)",
      "comment": "Add a rule to the ruleset and update the stats",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "subsetDL(double t, double k, double p)",
    "name": "subsetDL",
    "containingClass": {
      "qualifiedName": "weka.classifiers.rules.RuleStats",
      "name": "RuleStats",
      "isArray": false
    },
    "targetClass": "weka.classifiers.rules.RuleStats",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "double",
      "name": "double",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "t"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "k"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "p"
      }
    ],
    "protocol": {
      "member": "subsetDL(double t, double k, double p)",
      "comment": "Subset description length: <br> method_0 = -k*method_1-(n-k)method_2 Details see Quilan: \"MDL and categorical theories (Continued)\",ML95",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "theoryDL(int index)",
    "name": "theoryDL",
    "containingClass": {
      "qualifiedName": "weka.classifiers.rules.RuleStats",
      "name": "RuleStats",
      "isArray": false
    },
    "targetClass": "weka.classifiers.rules.RuleStats",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "double",
      "name": "double",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "index"
      }
    ],
    "protocol": {
      "member": "theoryDL(int index)",
      "comment": "The description length of the theory for a given rule. Computed as:<br> 0method_4* [||k||+ method_0]<br> where k is the number of antecedents of the rule; t is the total possible antecedents that could appear in a rule; ||K|| is the universal prior for k , log2*(k) and method_1 = -k*method_2-(n-k)method_3 is the subset encoding length.  Details see Quilan: \"MDL and categorical theories (Continued)\",ML95",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "dataDL(double expFPOverErr, double cover, double uncover, double fp, double fn)",
    "name": "dataDL",
    "containingClass": {
      "qualifiedName": "weka.classifiers.rules.RuleStats",
      "name": "RuleStats",
      "isArray": false
    },
    "targetClass": "weka.classifiers.rules.RuleStats",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "double",
      "name": "double",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "expFPOverErr"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "cover"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "uncover"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "fp"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "fn"
      }
    ],
    "protocol": {
      "member": "dataDL(double expFPOverErr, double cover, double uncover, double fp, double fn)",
      "comment": "The description length of data given the parameters of the data based on the ruleset.  Details see Quinlan: \"MDL and categorical theories (Continued)\",ML95",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "potential(int index, double expFPOverErr, double[] rulesetStat, double[] ruleStat, boolean checkErr)",
    "name": "potential",
    "containingClass": {
      "qualifiedName": "weka.classifiers.rules.RuleStats",
      "name": "RuleStats",
      "isArray": false
    },
    "targetClass": "weka.classifiers.rules.RuleStats",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "double",
      "name": "double",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "index"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "expFPOverErr"
      },
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "rulesetStat"
      },
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "ruleStat"
      },
      {
        "type": {
          "qualifiedName": "boolean",
          "name": "boolean",
          "isArray": false
        },
        "name": "checkErr"
      }
    ],
    "protocol": {
      "member": "potential(int index, double expFPOverErr, double[] rulesetStat, double[] ruleStat, boolean checkErr)",
      "comment": "Calculate the potential to decrease DL of the ruleset, imethod_0. the possible DL that could be decreased by deleting the rule whose index and simple statstics are given. If there's no potentials (imethod_0. smOrEq 0 && error rate < 0method_2), it returns NaN.  The way this procedure does is copied from original RIPPER implementation and is quite bizzare because it does not update the following rules' stats recursively any more when testing each rule, which means it assumes after deletion no data covered by the following rules (or regards the deleted rule as the last rule). Reasonable assumption?",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "minDataDLIfDeleted(int index, double expFPRate, boolean checkErr)",
    "name": "minDataDLIfDeleted",
    "containingClass": {
      "qualifiedName": "weka.classifiers.rules.RuleStats",
      "name": "RuleStats",
      "isArray": false
    },
    "targetClass": "weka.classifiers.rules.RuleStats",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "double",
      "name": "double",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "index"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "expFPRate"
      },
      {
        "type": {
          "qualifiedName": "boolean",
          "name": "boolean",
          "isArray": false
        },
        "name": "checkErr"
      }
    ],
    "protocol": {
      "member": "minDataDLIfDeleted(int index, double expFPRate, boolean checkErr)",
      "comment": "Compute the minimal data description length of the ruleset if the rule in the given position is deleted.<br> The min_data_DL_if_deleted = data_DL_if_deleted - potential",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "minDataDLIfExists(int index, double expFPRate, boolean checkErr)",
    "name": "minDataDLIfExists",
    "containingClass": {
      "qualifiedName": "weka.classifiers.rules.RuleStats",
      "name": "RuleStats",
      "isArray": false
    },
    "targetClass": "weka.classifiers.rules.RuleStats",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "double",
      "name": "double",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "index"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "expFPRate"
      },
      {
        "type": {
          "qualifiedName": "boolean",
          "name": "boolean",
          "isArray": false
        },
        "name": "checkErr"
      }
    ],
    "protocol": {
      "member": "minDataDLIfExists(int index, double expFPRate, boolean checkErr)",
      "comment": "Compute the minimal data description length of the ruleset if the rule in the given position is NOT deleted.<br> The min_data_DL_if_n_deleted = data_DL_if_n_deleted - potential",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "relativeDL(int index, double expFPRate, boolean checkErr)",
    "name": "relativeDL",
    "containingClass": {
      "qualifiedName": "weka.classifiers.rules.RuleStats",
      "name": "RuleStats",
      "isArray": false
    },
    "targetClass": "weka.classifiers.rules.RuleStats",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "double",
      "name": "double",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "index"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "expFPRate"
      },
      {
        "type": {
          "qualifiedName": "boolean",
          "name": "boolean",
          "isArray": false
        },
        "name": "checkErr"
      }
    ],
    "protocol": {
      "member": "relativeDL(int index, double expFPRate, boolean checkErr)",
      "comment": "The description length (DL) of the ruleset relative to if the rule in the given position is deleted, which is obtained by: <br> MDL if the rule exists - MDL if the rule does not exist <br> Note the minimal possible DL of the ruleset is method_0 instead of the DL of the current ruleset.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "reduceDL(double expFPRate, boolean checkErr)",
    "name": "reduceDL",
    "containingClass": {
      "qualifiedName": "weka.classifiers.rules.RuleStats",
      "name": "RuleStats",
      "isArray": false
    },
    "targetClass": "weka.classifiers.rules.RuleStats",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "expFPRate"
      },
      {
        "type": {
          "qualifiedName": "boolean",
          "name": "boolean",
          "isArray": false
        },
        "name": "checkErr"
      }
    ],
    "protocol": {
      "member": "reduceDL(double expFPRate, boolean checkErr)",
      "comment": "Try to reduce the DL of the ruleset by testing removing the rules one by one in reverse order and update all the stats",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "removeLast()",
    "name": "removeLast",
    "containingClass": {
      "qualifiedName": "weka.classifiers.rules.RuleStats",
      "name": "RuleStats",
      "isArray": false
    },
    "targetClass": "weka.classifiers.rules.RuleStats",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "removeLast()",
      "comment": "Remove the last rule in the ruleset as well as it's stats. It might be useful when the last rule was added for testing purpose and then the test failed",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "rmCoveredBySuccessives(weka.core.Instances data, java.util.ArrayList<weka.classifiers.rules.Rule> rules, int index)",
    "name": "rmCoveredBySuccessives",
    "containingClass": {
      "qualifiedName": "weka.classifiers.rules.RuleStats",
      "name": "RuleStats",
      "isArray": false
    },
    "targetClass": "weka.classifiers.rules.RuleStats",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "weka.core.Instances",
      "name": "weka.core.Instances",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "weka.core.Instances",
          "name": "Instances",
          "isArray": false
        },
        "name": "data"
      },
      {
        "type": {
          "qualifiedName": "java.util.ArrayList",
          "name": "ArrayList",
          "isArray": false
        },
        "name": "rules"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "index"
      }
    ],
    "protocol": {
      "member": "rmCoveredBySuccessives(weka.core.Instances data, java.util.ArrayList<weka.classifiers.rules.Rule> rules, int index)",
      "comment": "Static utility function to count the data covered by the rules after the given index in the given rules, and then remove them. It returns the data not covered by the successive rules.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "stratify(weka.core.Instances data, int folds, java.util.Random rand)",
    "name": "stratify",
    "containingClass": {
      "qualifiedName": "weka.classifiers.rules.RuleStats",
      "name": "RuleStats",
      "isArray": false
    },
    "targetClass": "weka.classifiers.rules.RuleStats",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "weka.core.Instances",
      "name": "weka.core.Instances",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "weka.core.Instances",
          "name": "Instances",
          "isArray": false
        },
        "name": "data"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "folds"
      },
      {
        "type": {
          "qualifiedName": "java.util.Random",
          "name": "Random",
          "isArray": false
        },
        "name": "rand"
      }
    ],
    "protocol": {
      "member": "stratify(weka.core.Instances data, int folds, java.util.Random rand)",
      "comment": "Stratify the given data into the given number of bags based on the class values. It differs from the method_0 that before stratification it sorts the instances according to the class order in the header file. It assumes no missing values in the class.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "combinedDL(double expFPRate, double predicted)",
    "name": "combinedDL",
    "containingClass": {
      "qualifiedName": "weka.classifiers.rules.RuleStats",
      "name": "RuleStats",
      "isArray": false
    },
    "targetClass": "weka.classifiers.rules.RuleStats",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "double",
      "name": "double",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "expFPRate"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "predicted"
      }
    ],
    "protocol": {
      "member": "combinedDL(double expFPRate, double predicted)",
      "comment": "Compute the combined DL of the ruleset in this class, imethod_0. theory DL and data DL. Note this procedure computes the combined DL according to the current status of the ruleset in this class",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "partition(weka.core.Instances data, int numFolds)",
    "name": "partition",
    "containingClass": {
      "qualifiedName": "weka.classifiers.rules.RuleStats",
      "name": "RuleStats",
      "isArray": false
    },
    "targetClass": "weka.classifiers.rules.RuleStats",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "weka.core.Instances[]",
      "name": "weka.core.Instances[]",
      "isArray": true
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "weka.core.Instances",
          "name": "Instances",
          "isArray": false
        },
        "name": "data"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "numFolds"
      }
    ],
    "protocol": {
      "member": "partition(weka.core.Instances data, int numFolds)",
      "comment": "Patition the data into 2, first of which has (numFolds-1)/numFolds of the data and the second has 1/numFolds of the data",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getRevision()",
    "name": "getRevision",
    "containingClass": {
      "qualifiedName": "weka.classifiers.rules.RuleStats",
      "name": "RuleStats",
      "isArray": false
    },
    "targetClass": "weka.classifiers.rules.RuleStats",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.lang.String",
      "name": "java.lang.String",
      "isArray": false
    },
    "parameters": [],
    "protocol": {
      "member": "getRevision()",
      "comment": "Returns the revision string.",
      "kind": "FreeText",
      "condition": ""
    }
  }
]